origin   skunkworks.everybitcounts.net2006
artifact relish_test_suite
package  basic_tests 

""" 
 test_packages.rel

 Test package importing, compiling, loading, linking.
"""

import
   machines/vehicles
   relish.pl2012/things/pkg/physical_objects as phys
   people

TEST_ATTRIBUTE_PERSISTENCE = false
TEST_TIME_METHODS = true
TEST_GOROUTINES = false
REST_OF_TEST = true
TEST_CONSOLE_INPUT = false

//
// if gt radius MAX_RADIUS
//    radius = MAX_RADIUS

MAX_RADIUS = 10


circleCircumference radius Float > Float
"""
 Calculates the circumference of a circle of a given radius.
"""
   => times 2 (times phys.PI radius) 


circleArea radius Float > Float
"""
 Calculates the area of a circle of a given radius.
"""
   if gt radius MAX_RADIUS
      radius = MAX_RADIUS
   r2 = times radius radius
   => times phys.PI r2


testReturnArgDefaults a Int > c Int d String e Int
"""
 Tests the return arg defaulting.
"""
   c = a
   

circleProperty radius Float prop String > Float
"""
 If prop is "a" calculates the area otherwise the circumference of a circle.
"""
   if eq "a" prop
      => circleArea radius
   else
      => circleCircumference radius


argTest
   a Float
   b String
   bar Int = 0
   ...v [] String
> 
   Float   
"""
 Test arguments to functions.
"""
   => a


listTest
   a Int
   b Int
   c Int
>
   [] Int
"""
 Puts some items in a list and returns the list.
"""   
   theList = [a b c]Int
   => theList


testReturns2More > Int Int
"""
 Returns two items.
"""
   => 4 5

testReturns2 > Int Int
"""
 Returns two items.
"""
   => testReturns2More


testReturnsTheTwoItGotMultiplied x Int y Int > Int 
"""
 Testing returning multiple values and receiving multiple
"""
   => times x y


spew mx Mutex chin InChannel inNum Int chout OutChannel outNum Int n Int
"""
 Exchanges data on channels and prints out what it is doing.
"""
   i = 0
   while 1
      i = plus i 1 
      lock mx
      print i "about to send" n "to ch" outNum
      unlock mx      
      chout <- n  
      lock mx 
      print i "sent" n "to ch" outNum
      print i "about to receive something from ch" inNum      
      unlock mx      
      m = <- chin
      lock mx    
      print i "got" m "from ch" inNum
      unlock mx


Basic
"""
 A datatype for testing storage and retrieval of primitive values.
"""
   b Bool


main
"""
 Main program.
"""
   if TEST_ATTRIBUTE_PERSISTENCE
      basic1 = Basic
      basic1.b = true

      if exists "BASIC 1"
         basic2 = summon "BASIC 1"
      else
         dub basic1 "BASIC 1"
         basic2 = basic1

      print basic2.b   

      basic2.b = false

      print basic2.b

      basic2.b = true

      print basic2.b

   cp = circleProperty 9.0 
                       "a"
   print cp
               
   print circleProperty 9.0 
                        "a" 

   print circleProperty 
            9.0 
            "a"                             
   print 
      circleProperty 
         9.0 
         "a"
   print circleProperty 9.0 "c"

   if REST_OF_TEST
      if TEST_CONSOLE_INPUT
         s = input "What is your first name?\n"
         print s      

      v1 v2 = testReturns2
      print v1 v2

      // FAILING !!!!!
      print testReturns2
      print testReturnsTheTwoItGotMultiplied testReturns2

      car1 = vehicles.Car
      car1.lat = 49.243
      car1.long = 123.761  // - operator is not handled yet
      car1.vin = "V0E44R8139WT6214A"

      truck1 = vehicles.PickupTruck
      truck1.lat = 49.265
      truck1.long = 123.778
      truck1.bedLength = 8.3

      engine1 = vehicles.Engine
      engine1.horsepower = 120
      car1.engine = engine1

      wheel1 = vehicles.Wheel
      wheel1.num = 1
      wheel2 = vehicles.Wheel
      wheel2.num = 2
      wheel3 = vehicles.Wheel
      wheel3.num = 3
      wheel4 = vehicles.Wheel
      wheel4.num = 4

      car1.wheels += wheel4  // Also NOT HANDLING // comment at beginning of indented line !!!
      car1.wheels += wheel3  

      if not exists "JSS 994"
         dub car1 "JSS 994"  // Moved this after some car1.wheels += to test persisting collection attr with owner obj
         dub truck1 "JAT 057"

      car1.wheels += wheel1  
      car1.wheels += wheel2  

      car2 = summon "JSS 994"  // Was Car summon - should it be: Car: summon

      print car2.lat
      print car2.vin

      print "car2.wheels:"

      for i wheel in car2.wheels
         print "wheel[" i "] =" wheel.num


      car2.wheels -= wheel2
      car2.wheels -= wheel3

      print "After removing wheels 2 and 3 from car2.wheels, car2.wheels is:"

      for i wheel in car2.wheels
         print "wheel[" i "] =" wheel.num

      

      bigWheels = []vehicles.Wheel "num > 2"

      for i wheel in bigWheels
         print "bigWheels[" i "] =" wheel.num

      spares = [wheel1 wheel2 wheel3]vehicles.Wheel

      print "spares[1] =" spares[1].num

      vcls = []vehicles.Vehicle "lat > 48" 
      for vhcl in vcls 
         print "boo"
         print vhcl.lat vhcl.long

      map1 = {"One"=>wheel1 "Two"=>wheel2 "Three"=>wheel3}String > vehicles.Wheel

      map2 = {}String > vehicles.Wheel

      //   map3 = {
      //            "One"   => wheel1 
      //            "Two"   => wheel2 
      //            "Three" => wheel3
      //          }String > vehicles.Wheel
      //
      //   map2["tres"] = map1["Three"]
      //   map2["doux"] = map1["Two"]
      //   
      //   wh = map[!"Four"]
      //   wh found = map1["Four"] // returns the mapped element or nil, plus whether the key was found
      //
      //   found = map1[?"Four"]  // query as to whether the key is found in the map.

      wheelFourFound = map1[? "Four"]
      print "map1[? \"Four\"] =" wheelFourFound
      print map1[! "Three"].num
      for key in map1
         print key
      for key val in map1
         print key val.num

      wh2 found = map1["Two"]
      print wh2.num found

      wh2 found = map1["two"]
      print wh2 found   

      map1["Four"] = wheel4

      print map1[! "Four"].num

      solarSystem = {
                       1 => "Mercury"
                       2 => "Venus"
                       3 => "Earth"
                       4 => "Mars"
                    }Int 
                     > 
                        String

      print solarSystem[! 1]

      outerSolarSystem = {
                            "Jupiter" => 5
                            "Saturn"  => 6
                            "Uranus"  => 7
                            "Neptune" => 8
                         }String > Int 

      for k v in outerSolarSystem
         print k v   


      sales = [1.29 4.25 0.33 5.981]
      print sum sales  // should print 11.851

      scores = [22 9 0 13]
      print sum scores  // should print 44

      taxedSales = [
                      for sale in sales
                         times sale 1.10
                   ]Float

      print sum taxedSales

      opps = {
                for ky vl 
                   in 
                      ["left" "up" "inside"]
                      ["right" "down" "outside"]
                   ky vl
             }String > String
      
      for key9 val9 in opps
         print key9 val9
      print opps["left"] opps["up"]

      opps2 = {
                 for val3 in ["left" "up" "inside"]
                    val3
                    cat "[" val3 "]"
              }String > String
      
      for key8 val8 in opps2
         print key8 val8
      print opps2["left"] opps2["up"]
    
      a = """
This is the very first
multi-line string in relish!!
"""

      print a

      b = fill """
This is the #%s
multi-line %s string in relish!!
"""
               2
               "substitutable"

      print b

      if not 0
         print "0 is zero"
      else
         print "0 is non-zero"

      print not bigWheels

      smallWheels = []vehicles.Wheel

      print not smallWheels

      print "Length 18-byte string =" (len "Well how big am I?")
      print "len bigWheels =" (len bigWheels)
      print "len smallWheels =" (len smallWheels)
      print "len car2.wheels =" (len car2.wheels)

      lastOne = and 2 "three" true "five"
      print lastOne

      firstOne = or 0 0.0 "" "this one" "is true"
      print firstOne

      print plus 2 2

      print plus 2 2.3

      print minus 2.3 2

      print minus 3 2

      print div 8 3

      print div 8 3.0

      print mod 7 3


      driver1 = people.Person
      driver1.firstName = "Joe"
      driver1.lastName = "Armstrong"
      driver1.dateOfBirth err = Time "1983-09-25T22:13:45.875Z"
      if err
         print err

      print driver1.dateOfBirth

      passenger1 = people.Person
      passenger1.firstName = "Alice"
      passenger1.lastName = "Wong"
      passenger1.dateOfBirth err = Time "1990-02-13 22:13:45 America/Los_Angeles"   
      if err
         print err   

      passenger2 = people.Person
      passenger2.firstName = "Ernie"
      passenger2.lastName = "Kovacs"
      passenger2.dateOfBirth err = Time "February 3, 1969 8:08am -0700 PDT" "January 2, 2006 3:04pm -0700 MST"    
      if err
         print err   

      driver2 = people.Person
      driver2.firstName = "Jane"
      driver2.lastName = "Sterrit"
      driver2.dateOfBirth err = Time 1983 5 27 15 4 0 0 "Local"
      if err
         print err   

      car2.driver = driver1
      car2.passengers += passenger1
      car2.passengers += passenger2

      for person in car2.passengers
         print person.firstName person.lastName person.dateOfBirth

      car3 = passenger2.vehicleRiddenIn
      print car3.vin     

      print car2.passengers[1].firstName

      truck1.driver = driver2
      
      youngsters = []people.Person "dateOfBirth > '1982-09-23'"

      for person in youngsters
         print person.firstName person.lastName

      s1 = "How now brown cow?"
      
      s2 = "bro"

      s3 = "世界Hello"

      s4 = "one"
      s5 = "two"
      s6 = "three"
      count = [s4 s5 s6]String
      print join count ","
      print join count
      v1 = nil
      assortment = ["one" 2 3.0 "four" v1 false]Any
      print join assortment "|"

      assortment[1] = "Two"
      print join assortment "|"

      print first s1 2
      print first s1 30
      print last s1 4
      print last s1 30
      print replace s1 "ow" "ew"
      print replace s1 "ow" "ew" 1   
      print hasPrefix s1 s2
      print hasPrefix s1 "How"
      print hasSuffix s1 "cow"
      print hasSuffix s1 "cow?"
      print cat s1 s2 " " driver1.firstName
      print index s1 s2
      print lastIndex s1 "ow"
      print slice s1 4 7
      print slice s1 0 (neg 1)
      print slice s1 1 (neg 5)  
      print slice s1 8
      print first s3 1
      print first s3 2
      print first s3 3
      print len s3
      print numCodePoints s3
      print index s3 "世界"
      print index s3 "界"

      print base64Hash s3

      print hexHash s3   

      a1 a2 a3 = testReturnArgDefaults 9

      print "a1" a1 "a2" a2 "a3" a3

      if TEST_TIME_METHODS
         print driver1.dateOfBirth
         t2 = 
            plus 
               driver1.dateOfBirth 
               plus (hours 50) (minutes 30)     
         t3 = plus driver1.dateOfBirth (duration 50 30)
         t4 = addDate driver1.dateOfBirth 1 0 2      
         print t2
         print t3
         print t4
         print minus t3 t2
         print minus t3 (hours 50)    
         print now "Local"
         now1 = now "UTC"    
         sleep seconds 3
         ns = since now1 
         print secondsEquivalentOf ns
         h m s ns = timeParts ns
         print h m s ns                

      if TEST_GOROUTINES

         // If executed, this section will cause the test program to keep running
         // and spewing output to stdout.

         ch1 = Channel
                  1
         ch2 = Channel
         mx = Mutex

         go spew mx ch1 1 ch2 2 5

         spew mx ch2 2 ch1 1 3

