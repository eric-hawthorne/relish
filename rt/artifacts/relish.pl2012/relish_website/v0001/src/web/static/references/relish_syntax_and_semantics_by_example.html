<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>
relish by example - relish programming language
</title>

<meta name="keywords" content="relish programming language web application development framework persistence" />
 <meta name="description" content="Home page for relish(TM), an application programming language which includes a simple full-stack web application framework and transparent persistence. Focus is on simplicity and minimalism via very strict enforcement of conventions. The name comes from the language's inbuilt construct of relations between datatypes. A programmer can express an entity-relation model of the application domain directly in the language then associate instances. Methods are owned by tuples of datatypes, and are dispatched by multi-argument multimethod dispatch.
relish is implemented in Go, and inherits/wraps some Go features like goroutine concurrency and channels, but is almost entirely unlike Go in language constructs and philosophy." />
 

 <link rel="stylesheet" type="text/css" id="stylesheet"
       href="/styles/default.css" />


</head>
<body>
  <div id="header">	
  <table>
	<tr>
	  <td>	
        <img src="/relish_logo4_small.png">
      </td>
	  <td>	
         &nbsp; &nbsp;
      </td>
	  <td>	
        <h1>relish<span class="trademark">&#8482;</span></h1>
      </td>
	  <td style="width: 4em">	
         &nbsp; &nbsp;
      </td>
	  <td>	
        <h2>relish Syntax and Semantics By Example <span class="h2small">- From the Inside Out</span></h2>

      </td>
    </tr>
  </table>
  </div>
  <div id="tutorials_button" class="menubutton">
	Tutorials
  </div>
  <div id="references_button" class="menubutton">
	References
  </div>
  <div id="packages_button" class="menubutton">
	Packages
  </div>
  <div id="download_button" class="menubutton">
	DOWNLOAD
  </div>	
<div id="index">
	<a href="#Introduction">Introduction</a><br/>	
	<a href="#Variables">Variables</a><br/>
	<a href="#ReservedWords">Reserved Words</a><br/>
	<a href="#Constants">Constants</a><br/>	
	<a href="#DataTypes">Data Types</a><br/>	
	<a href="#TypeParameters">Type Parameters</a><br/>	
	<a href="#InbuiltDataTypes">Inbuilt Data Types</a><br/>			
  <a href="#LiteralValues">Literal Values</a><br/>   	
  <a href="#AssignmentStatements">Assignment Statements</a><br/>    
  <a href="#ConstantDeclarations">Constant Declarations</a><br/>   
  <a href="#ControlStatements">Control Statements</a><br/>   
</div>  
<div id="content_manual">
	<a name="Introduction"><h3>Introduction</h3></a>

			<p>
			This reference manual shows and explains relish&#8482; programming language constructs, starting from the most basic expressions and statements, and proceeding on to control constructs and beyond. Each construct is shown by one or more examples. Text after or interleaved with the examples explains the syntax rules and the semantics of the construct. <span class="future">language features planned but not yet implemented or enforced by the language compiler-interpreter or runtime environment are shown in text of this colour.</span>
			</p>
			<p>
				relish language constructs have simple syntax rules and minimal use of punctuation and brackets of various kinds. The language also has fewer reserved words than may be typical. However, the language achieves this simplicity and minimalism of expression by means of a trade-off; programmers must adhere to stricter rules than usual as to how and where each language construct is to be written in the program source text.
			</p>
			<p>
				Because of these strict syntax and code layout rules, it is strongly suggested that you begin creating relish programs, when you are first learning the language, by copy-pasting examples of language constructs from tutorials, example programs, code recipes, or from this manual. 
				The examples will be formatted and laid out correctly, and you can modify the code to your needs from that starting point, and learn the conventions as you go.
			</p>

	<a name="Variables"><h3>Variables</h3></a>		
    <code>
    a  b  c  a1  source240v  amount lineWidth  stateOfPlay  line1Length  bitWidth32  
    </code><br/><br/>
    Usage in context:<br/><br/>
    <code>
    a = 2<br/>
    lineWidth = a
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Variable names are camel-case latin-1 alphanumeric beginning with a lower case letter.
Digits count as lower case letters in the camel-case rule, except are not allowed as the first character of the name as
a whole, nor as the first character of any lower case word after an upper case letter. So theWord2 is allowed but theW2 is not.
The name as a whole cannot end with an upper case letter. Multiple upper case letters together are not permitted.
Note that underscores are not permitted (since they are an alternative to camel-case word separation.)    	
    </p>
<p>
Some names of this form may not be used as variable names:
<ul>
<li>the relish language's reserved words are excluded,</li>
<li>the name of any method visible in the scope,</li>

<li> the last name-part of any unaliased imported package,</li> 
<li> the package alias of any aliased imported package,</li> 
<li><span class="future">a name of a parameter of the containing method is already implicitly defined as a strictly typed variable in the method so may not be re-assigned to a value-type incompatible with the parameter's type specification.</span></li>	
</ul>
</p>

        <p>
    	<b>Semantics:</b>
    </p>
    <p>
	A variable is a named and re-assignable store for a value of an expression. The variable can be used as an expression, and yields the value that is stored in it at the time it is used as an expression. All variables are local variables inside a <a href="#Methods">method</a> body. 
	Variables are created by their first use in a method body. If the value assigned to a variable is a structured object or a collection, then the assignment is by reference, not by value-copy. Simple primitive values such as Int, Float are assigned by value.
    </p>
	

	<span class="future">The type of a variable is not stated explicitly when defining the variable. If you assign to a variable in multiple places inside a method body, the known types of the values assigned in the different places must form a type hierarchy. That is, if values of different known types are
	assigned in different assignment-occurrences, then at least one of those known types must be a common supertype of all the others. The type of the variable is then taken to be that common supertype of the known types of values assigned to it in the various assignment occurrences in the method. 
    </span>





	<a name="ReservedWords"><h3>Reserved Words</h3></a>		
    <code>
    if elif else while for in as break continue of go func true false nil
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>    
    <p>
The reserved words may not be used as variable names, method names, or package name parts or aliases. They are reserved for use to define control constructs and literal values in the language.
</p>


	<a name="Constants"><h3>Constants</h3></a>		
    <code>
    PI  E  MAX_WIDTH  LIMIT1  DIM1_SIZE 
    </code><br/><br/>
    Usage in context:<br/><br/>
    <code>
    PI = 3.1415926535<br/>
    DEFAULT_GREETING = "Hello, World!"
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Constant names are all-capitalized latin-1 alphanumeric, with single-underscore word separators permitted.
They must begin with a latin-1 capital letter.
Note: All single latin-1 capital letters except T denote constants. T,T1,... denote <span class="future">type parameters (See below.)</span> 	
    </p>
    <p>
    Constants must be defined at the top-level scope of a source code file. They cannot be defined within a method body.
    Constants are visible throughout the package in which they are defined. If their name is referred to inside a package that imports
    the constant-defining package, and if the constant name has been package-qualified in that use, the constant is visible
    in the package that imports the constant-defining package. <span class="future">However, if a constant is defined within the __private__ section of a source code file, its name is never visible outside the defining package.</span>
    </p>
        <p>
    	<b>Semantics:</b>
    </p>
    <p>
    	A constant can (and must when introduced) be assigned the value of an expression once, and thenceforth refers to that value.
    	<span class="future">There must be a restriction on the kind of expressions that can be assigned to constants, due to timing of the execution of the constant assignment statements, but what is that restriction?
    		When in the code load and generation and initialization sequence does the constant expression get evaluated??? Does this need to be changed to move the execution until all the methods etc are properly loaded into the runtime?</span>
	</p>



	<a name="DataTypes"><h3>Data Types</h3></a>		
    <code>
    Int32  Float  String  ClosedCurve  BuggyWhipStorageRackClip    	
    </code><br/><br/>
    Usage in context:<br/>
<code><pre>
add a Float b Float &gt; Float
"""
 A method that adds two floating-point numbers together and returns the result.
"""
</pre></code>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Type names are camel-case latin-1 alphanumeric beginning with an upper case letter.
All data type names must begin with at least two letters (upper case followed by lowercase.)
Other details of the name syntax are the same as for variables except for the initial upper case letter for type names.
Note that underscores are not permitted (since they are an alternative to camel-case word separation.)	
    </p>
    <p>
    Data types must be defined at the top-level scope of a source code file. They cannot be defined within a method body.
    Type names are visible throughout the package in which they are defined. If their name is referred to inside a package that imports
    the type-defining package, and if the type name has been package-qualified in that use, the type is visible
    in the package that imports the type-defining package. <span class="future">However, if a data type is defined within the __private__ section of a source code file, its name is never visible outside the defining package.</span>
    </p>
        <p>
    	<b>Semantics:</b>
    </p>
    <p>
    	Each data object/value in a relish program has a data type. The data type of an object/value determines which methods can accept the object/value as an argument, and which methods can return the object/value as one of the method's return values.
	</p>
	<p>
		Data types in relish can inherit attributes and method compatibility from other data types. A data type can inherit from more than one direct supertype. That is, relish has multiple inheritance.
	</p>
	<p>
		Data types are of three kinds, primitive value types, structured object types, and collection types.
	</p>
	<p>
		Primitive value types are such types as Int and Bool and <span class="future">Rune (unicode character)</span>.
	</p>
	<p>
        Structured object types are like the familiar "object classes" of other languages.
        A structured object type is defined by specifying a list of attribute specifications to define the attributes of the object.
        See "data type definition" section for details.        

    <p>
        Collection types are types such as List of T, Map of T T1, Set of T and have element accessing and iterating syntax support in the language, as well as compact syntax support for adding and deleting elements, if the collection is mutable. 
		<span class="future">String may be considered an immutable collection type.</span>
	</p>
	<p>
		<span class="future">Generics: - why are generics always "future" :-(  Data type definitions and type specifications may be parameterized; that is, the type may be defined as a wrapper or holder of objects/values of one or more other data types. For example, BinaryTreeNode of T T is a parameterized data type where the type parameter T stands for any other data type. Each parameterized data type definition effectively creates a set of possible data types, and each parameterized data type specification accepts a set of possible datatypes.</span>
	</p>	
	<p>
		In general, in relish, a data type (or class) does not "own" a set of methods.
		It is more accurate to say that an <b>n-tuple</b> (e.g. an ordered-pair, an ordered triple) of data types in relish owns a set of methods; the n-tuple of types conceptually owns those methods whose parameter signature (of all positional-argument input parameters) is that type tuple.</p>
		<p>
		Methods do not have a privileged argument object which is known as the receiver of the method call.
		Rather, all objects that are (required positional) arguments are the receivers of the method call, and relish's dynamic method dispatch will take account of the actual specific data type of each of the positional argument objects supplied to the call, to decide which method has a parameter type-signature that is the most specifically matching the tuple of argument objects.
     		</p>
		<p>A data type (or class) in relish can only be said to own 1) unary methods whose only input parameter is specified to be of that type, <span class="future">and also 2) special attribute-setter methods which set the values of attributes of a structured data object.</span>
	</p>





		<a name="TypeParameters"><h3><span class="future">Type Parameters</span></h3></a>		
	    <code>
	    <span class="future">T  T1  T2  T3  T4  T5  T6  T7  T8  T9</span>
	    </code><br/><br/>
	    <span class="future">Usage in context:<br/></span>
<code><pre>
<span class="future">LinkedList of T</span>	   
</pre></code>
	    <p>
	    	<span class="future"><b>Syntax:</b></span>
	    </p>
	    <p>
<span class="future">Relish supports parameterized data types (generics) and
	only the names above are valid as type parameters in 
	parameterized type declarations.</span> 	
	    </p>
	   


			<a name="InbuiltDataTypes"><h3>Inbuilt Data Types</h3></a>	
			
			<p>In the following, Type1 &lt;: Type2 denotes that Type1 is a subtype that inherits behaviour from and extends the definition of the supertype Type2</p>	
		    <code><pre>
Any                              (implicit) Abstract supertype of all relish datatypes
RelishPrimitive &lt;: Any           Abstract supertype of all inbuilt primitive data types in relish

Numeric &lt;: RelishPrimitive       Abstract supertype of all primitive number types
Integer &lt;: Numeric               Abstract supertype of all integer types
Int &lt;: Integer                   64-bit signed integer
Int32 &lt;: Integer                 32-bit signed integer<span class="future">
Int16 &lt;: Integer                 16-bit signed integer
Int8 &lt;: Integer                  8-bit signed integer</span>
Uint &lt;: Integer                  64-bit unsigned integer
Uint32 &lt;: Integer                32-bit unsigned integer<span class="future">
Uint16 &lt;: Integer                16-bit unsigned integer
Byte &lt;: Integer                  8-bit unsigned integer
Bit &lt;: Integer                   1-bit unsigned integer</span>
Bool &lt;: RelishPrimitive          Boolean logical type (true,false)
Real &lt;: Numeric                  Abstract supertype of all floating-point numeric types
Float &lt;: Real                    64-bit floating-point number<span class="future">
Float32 &lt;: Real                  32-bit floating-point number
ComplexNumber &lt;: Numeric         Abstract supertype of all complex numeric types
Complex &lt;: ComplexNumber         Complex number consisting of two 64-bit Float parts
Complex32 &lt;: ComplexNumber       Complex number consisting of two 32-bit Float32 parts

Text &lt;: RelishPrimitive          Abstract supertype of all text data types
CodePoint &lt;: Text                A 32-bit unsigned integer representing a Unicode codepoint</span>	 
String &lt;: Text                   immutable byte-array representing UTF-8 encoded CodePoints.<span class="future">			
Callable &lt;: RelishPrimitive      Abstract supertype of all function types
MultiMethod &lt;: Callable          A set of methods in a namespace that share the same name
Method &lt;: Callable               An executable function implementation

NonPrimitive &lt;: Any              Abstract supertype of any type which is not a RelishPrimitive             
Struct &lt;: Any                    Abstract supertype of programmer-defined structured object types
Collection of T &lt;: Any           Abstract supertype of collection classes e.g. List Set Map
List of T &lt;: Collection of T     Collection which maintains elements in a sequence
Set of T &lt;: Collection of T      Collection which holds at most one of each value
Map of T1 T2 &lt;: Collection of T1 Map from one data type to another 

InChannel &lt;: Any                 A channel which can be read from
OutChannel &lt;: Any                A channel which can be written to
Channel &lt;: InChannel OutChannel  A channel which can be read from and written to</span>
</pre></code>
<p><span class="future"><em>Some issues here. Should Struct and Collection and Channel be NonPrimitive? </em></span></p>
		   






  <a name="LiteralValues"><h3>Literal Values</h3></a>    

<h4>Integer literals</h4>
    <code>
    42<br/>
0600<br/>
0xBadFace<br/>
170141183460469231731687303715884105727<br/>  
<span class="future">-42<br/>
-0600<br/>
-0xBadFace<br/>
-170141183460469231731687303715884105727<br/></span>
    </code><br/>
    Usage in context:<br/><br/>
    <code>
    a = 42<br/>
    color = 0xFFCADD<br/>
    <span class="future">n = plus -42 260<br/></span>
    </code>
    <p>
An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0 for octal, 0x or 0X for hexadecimal. In hexadecimal literals, letters a-f and A-F represent values 10 through 15. An optional negation prefix - (which if present must come before the non-decimal base prefix) negates the value represented by the sequence of digits. The negation prefix cannot appear in a literal whose value is 0
    </p>


<h4>Floating-point number literals</h4>

<code><pre>
0.
0.0
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
<span class="future">-72.40
-072.40  // == -72.40
-2.71828
-1.e+0
-6.67428e-11
-1E6
-.25
-.12345E+5</span>
</pre></code>
    Usage in context:<br/><br/>
    <code>
    PI = 3.14159265357989<br/>
    r = 6.67428e-2<br/>
    <span class="future">p = -1.7<br/></span>
    </code>
    <p>
A floating-point literal is a decimal representation of a floating-point constant. It has an integer part, a decimal point, a fractional part, and an exponent part. The integer and fractional part comprise decimal digits; the exponent part is an e or E followed by an optionally signed decimal exponent. One of the integer part or the fractional part may be elided; one of the decimal point or the exponent may be elided.  An optional negation prefix - negates the value represented by the sequence of digits. The negation prefix cannot appear in a literal whose value is 0.
</p>

<h4>Boolean literals</h4>

<code><pre>
true  false
</pre></code>
Usage in context:<br/>
<code><pre>
DEBUG = false

while true
   doSomethingForever
</pre></code>
    <p>
Boolean literals represent the boolean logic values true and false, which are the only two values of inbuilt data type Bool. 
false is the zero-value of the Bool type.  
</p>
<p>
NOTE: In relish, the zero-value of any data type is considered false-equivalent in logical tests (as in "<b>if</b>" "<b>while</b>" "<b>for</b>") and is also considered false-equivalent in the Boolean logic operator functions "<b>and</b>" "<b>or</b>" and "<b>not</b>". nil (non-present non-primitive object) is also considered false.
</p>
So values that test false or act as false in boolean operator functions are:
<pre>
0
0.
false
[]   // empty list
{}   // empty set
{=>} // empty map
""   // empty string
nil
</pre>
All other values of any data type test non-false, and act non-false in boolean operator functions.
</p>


<h4>String literals</h4>

<code><pre>
"Hello, world!\n"  
"\n"
""
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"       // illegal: surrogate half
"\U00110000"   // illegal: invalid Unicode code point

These examples all represent the same string:

"日本語"                                 // UTF-8 input text
"\u65e5\u672c\u8a9e"                    // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // the explicit UTF-8 bytes

A multi-line raw string:

      """
"""   
It was a dark and stormy night.
I had a premonition that I should not keep
writing this long, overwrought, badly formatted, 
and turgidly melodramatic story,
but I couldn't help myself. "Damn!", I said to myself,
this is the end.
"""
</pre></code>
    Usage in context:<br/>
<code><pre>
   firstName = "Jeremiah"
   aphorism = """
"""
No matter where you go,
There you are!
And notice that where I am
is starting at the first column
of the source code file.
But then notice that indentation resumes after me, as if I
weren't present in the source file.
"""
   lastName = "Jones"
   truism = """
"""
Stupid is as
stupid does.
"""   
   age = 9

</pre></code>
    <p>
Strings in relish (currently) exhibit and behave much as string values do in Go, because their underlying implementation is a Go string. 
</p>
<p>
A String literal represents a String constant obtained from concatenating a sequence of characters. There are two forms: single-line interpreted String literals and multi-line raw String literals.
</p>
<p>
Interpreted String literals are character sequences between double quotes "". The text between the quotes, which may not contain newlines, forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \' is illegal and \" is legal), with the same restrictions. The three-digit octal (\nnn) and two-digit hexadecimal (\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \377 and \xFF represent a single byte of value 0xFF=255, while ÿ, \u00FF, \U000000FF and \xc3\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.
</p>
<p>
Multi-line raw String literals are character sequences between triple-doublequote delimiters. 
Within the delimiters, any character is legal. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the delimiters; in particular, backslashes have no special meaning and the string may contain newlines. Carriage returns inside raw string literals are discarded from the raw string value.
</p>
<p>
Because of the heavily indentation-dependent nature of relish source code, multi-line raw string literals are first introduced
in their proper indented location, by a single """. On the following line, there must be another """ at the beginning of the line.
The actual raw string value begins on the next line; the one after the second """. 
The raw string continues until the next (third) """, which must again occur at the beginning of a line of the source code file.
So raw strings are always multi-line. Raw string literal values do not include the initial newline character, but do include the last newline character.
The shortest possible multi-line raw string is 
<pre>
   s = """
"""
"""
</pre>
Which is equivalent to the interpreted string literal "\n". 
</p>
</p>
<p>
One peculiarity of Go strings is that their index operator returns a byte at the ith byte position, whereas the string is fundamentally supposed to be a 
sequence of utf-8 encoded unicode codepoints. Each codepoint, utf-8 encoded, can occupy multiple bytes of the string. Also, disturbingly, the len function of a Go string returns the number of bytes, not the number of unicode codepoints in the string. I don't really like these split-personality
grudgingly unicode behaviours of Go strings, but relish Strings are stuck with them for now.
</p>


	<a name="AssignmentStatements"><h3>Assignment Statements</h3></a>		
    <code><pre>
a = 9

bigBigVariableName = 
   "A very very very very very very very very very long value might have to be on the next line, indented."

a b c = d "something" f

a b c = 9432
        "a string"
        d 

a b c =
   d
   143.65
   f    

obj1.obj2.obj3.a = 143.65

myList[3].myMap["Joe Bloggs"].a[i] = "3155 Kent Street"

coord[0].lat = 49.5
    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
An assignment statement consists of one or more assignable left-side-expressions, followed by the assignment operator "=" followed by one or more expressions that (collectively) must produce the <em>same number</em>** of values as the number of assignable left-side expressions. The "=" must be preceded by a single space. If the right-side expressions are on or begin on the same line as the "=", the ""=" must be followed by a single space, which is followed by the beginning of first right-side expression.
</p>
<p>
The left-side expressions must be simple enough to fit on one-line. The second and subsequent left-side expressions, if any, must be separated from their predecessor by a single space. A Left-side expression must be one of:
<ol>
	<li>A local variable or method parameter in a method body.</li>
	<li>An attribute of a structured object.  
	<li>An indexed position in an ordered collection or a map, specified by <expr>[i] or <expr>[key].
	<li>A path of expressions separated by the infix "." operator. The first expression must be a local variable, method parameter, or an indexed position in a collection/map-valued variable or parameter.  Each subsequent expression in the path may be the name of a unary function, an attribute, or an attribute-getter-function, or may be an indexed position in the value returned by one of these. 
</ol>
</p>
<p>
The right-side expressions may appear in several spatial configurations in the source code file.
<ul>
<li>The first configuration is in-line on the same line as the left side and the " = ". In this configuration, if there are multiple expressions, they must be simple so it is not ambiguous where one expression ends and the next begins. Each of the multiple expressions on the line must be one of a) a simple literal, b) a variable name, c) an index expression, dot-notation expression, or combination thereof, or d) a method call enclosed in brackets (foo a "b"), where the method call itself has only simple literals, variable names, index expressions, or dot-notation expressions as arguments. </li>
<li>The second configuration is multiple right side expressions stacked one below the other, starting with the first right-side expression in its normal in-line position one space to the right of the "=" operator. </li>
<li>The third configuration is one or more right-side expressions stacked one below the other, starting on the line following the left-side expressions and " =". In this case, the right-side expressions must all be indented one indent level from the indent position of the beginning of the assignment statement as a whole. </li>
</ul>
</p>
<p>
**There is one exception to the rule that the right-side expressions must produce the same number of values as the number of l-expressions. The right-side may consist of a single expression which evaluates to an ordered collection (e.g. a list or ordered set) containing exactly the same number of elements as the number of l-expressions. 
</p>
</p>
<p>
<b>Semantics:</b>
</p>



<p>
<span class="future">Restrictions apply that limit which assignments are legal, based on type compatibility considerations and on writeability permissions of object attributes and collections. </span>
</p>
<p>
<span class="future"><em>In the following, the term "the statically known type" of an expression refers to the most specific data type that it can be assumed applies to the expression, based on compile-time type information, lexical program structure, and type inference.</em> </span>
</p>
<dl>
<dt>Assigning to a local variable</dt>
<dd><span class="future">Inside a method body, you can assign a value to a variable. The first encountered assignment implicitly creates the variable. There may be multiple lexical occurrences of assignment to the same variable in the method body. The variable is (implicitly) assigned a type constraint; the (most general) statically known type of the values assigned to it among the different lexical assignment occurrences.
<br/>
	There is a type restriction on assignments to the same variable within a method body: There must exist a statically known type among those of the values assigned to the variable which is a supertype of (or the same as) all of the other statically known types of values assigned to the variable in the method body. </span></dd>	
<dt>Assigning to a parameter of a method</dt>
<dd><span class="future">Inside a method body, you can assign a new value to a parameter of the method. Method parameters are declared with a data type specification. The value you assign to the parameter must be compatible with (same as or a subtype of) the type specified for the parameter.</span></dd>

<dt>Assigning to an attribute of a structured object</dt>
<dd><span class="future">You can assign a value to an attribute of an object. Object attributes are declared with a data type specification. The value you assign to the attribute must be compatible with (same as or a subtype of) the type specified for the attribute. 
<br/>
<!-- Some attributes are flagged as not writeable, or not writeable in certain contexts. Blah blah blah. -->
</span></dd>

<dt>Assigning to an indexed position in a collection or map</dt>
<dd><span class="future">You can assign a value to a position in a mutable ordered collection or a mutable map, or to a position in an ordered multi-valued attribute. Collections, maps, and multi-valued attributes are declared with an element data-type specification. The value you assign to the position in the collection/map/multi-valued attribute must be compatible with (same as or a subtype of) the element data-type specification. 
<br/>
<!-- Some collections are immutable. Blah blah blah. -->
</span></dd>
</dl>











	<a name="ConstantDeclarations"><h3>Constant Declarations</h3></a>	
<!-- PI Float32 = 3.14159265357989 -->		
    <code><pre>
PI = 3.14159265357989

E = 2.17  // or roughly anyway

MAX_WIDTH = 1024
    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
A constant declaration consists of a constant name, followed by the assignment operator "=" followed by an expression. The "=" must be preceded by a single space. If the right-side expression is on or begins on the same line as the "=", the ""=" must be followed by a single space, which is followed by the beginning of the right-side expression.
</p>
<p>
The right-side expression may appear in several spatial configurations in the source code file.
<ul>
<li>The first configuration is in-line on the same line as the left side and the " = ".  </li>
<li>The second configuration has the right-side expression starting on the line following the constant name and " =". In this case, the right-side expression must all be indented one indent level from the indent position of the beginning of the constant declaration. </li>
</ul>
</p>
<p>
A constant declaration can only appear at the top-level lexical scope in a source code file. That is, it must begin in the 1st column of the source code file. It may not occur inside a method body or type declaration.
</p>
</p>
<p>
<b>Semantics:</b>
</p>
<p>
A constant can only be assigned a value once, at its declaration. The name then represents that value and can be used as the value in an expression.
Constant names are exported from the package in which they occur <span class="future">unless they are declared within the __private__ section of a source code file, in which case they are only visible within the package.</span>
</p>



	<a name="ControlStatements"><h3>Control Statements</h3></a>	
	
	<h4>"if" conditional</h4>
    <code><pre>
	
if lt x 0
   x = neg x

if lt x 0
   x = 0
else
   x = 1
	
if some
      condition
      expression
   statement
   statement
elif another condition
             expression
   statement
   statement
   statement
elif aThird condition expression
   statement
else
   statement
   statement
    </pre></code>
<p>
<b>Semantics:</b>
</p>
<p>
If the test expression evaluates to any non-false value, the immediately following indented clause (statement sequence) is	executed,
otherwise control passes to the next elif test if present, or to an else clause if only that is present, or to the statement following the "if", if neither another elif or an else are present.
If none of the if or elif tests pass, and an else is present, its indented clause (statement sequence) is executed.
</p>
<p>
"if" is a statement but not an expression. It does not return a value.
</p>

	<h4>"while" loop</h4>
    <code><pre>
while neq (location cows) home
   herd cows	
   sleepRough
   drink COWBOY_COFFEE
	
while some
         condition
         expression
   statement
   if condition
      break
   elif condition2
      continue
   statement
elif another condition
             expression
   statement
   statement
elif aThird condition expression
   statement
else
   statement
   statement
    </pre></code>
<p>
<b>Semantics:</b>
</p>
<p>
While the test expression evaluates to any non-false value, the immediately following indented clause (statement sequence) is executed, then the 
test expression is evaluated again, and so on.
</p>
<p>
"while" is a statement but not an expression. It does not return a value.
</p>
<p>
A while conditional can optionally include alternative clauses (elif,else). The alternative clauses are tested/invoked only if the while condition is false initially (i.e. if the loop is not entered).
</p>

	
</div>

</body>
</html>