<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>
relish by example - relish programming language
</title>

<meta name="keywords" content="relish programming language web application development framework persistence" />
 <meta name="description" content="Home page for relish(TM), an application programming language which includes a simple full-stack web application framework and transparent persistence. Focus is on simplicity and minimalism via very strict enforcement of conventions. The name comes from the language's inbuilt construct of relations between datatypes. A programmer can express an entity-relation model of the application domain directly in the language then associate instances. Methods are owned by tuples of datatypes, and are dispatched by multi-argument multimethod dispatch.
relish is implemented in Go, and inherits/wraps some Go features like goroutine concurrency and channels, but is almost entirely unlike Go in language constructs and philosophy." />
 

 <link rel="stylesheet" type="text/css" id="stylesheet"
       href="/styles/default.css" />


</head>
<body>
  <div id="header">	
  <table>
	<tr>
	  <td>	
        <img src="/relish_logo4_small.png">
      </td>
	  <td>	
         &nbsp; &nbsp;
      </td>
	  <td>	
        <h1>relish<span class="trademark">&#8482;</span></h1>
      </td>
	  <td style="width: 4em">	
         &nbsp; &nbsp;
      </td>
	  <td>	
        <h2>relish Syntax and Semantics By Example <span class="h2small">- From the Inside Out</span></h2>

      </td>
    </tr>
  </table>
  </div>
  <div id="tutorials_button" class="menubutton">
	Tutorials
  </div>
  <div id="references_button" class="menubutton">
	References
  </div>
  <div id="packages_button" class="menubutton">
	Packages
  </div>
  <div id="download_button" class="menubutton">
	DOWNLOAD
  </div>	
<div id="index">
	<a href="#Introduction">Introduction</a><br/>	
	<a href="#Variables">Variables</a><br/>
	<a href="#ReservedWords">Reserved Words</a><br/>
	<a href="#Constants">Constants</a><br/>	
	<a href="#DataTypes">Data Types</a><br/>	
	<a href="#TypeParameters">Type Parameters</a><br/>	
	<a href="#InbuiltDataTypes">Inbuilt Data Types</a><br/>			
  <a href="#LiteralValues">Literal Values</a><br/>   	
  <a href="#AssignmentStatements">Assignment Statements</a><br/>    
  <a href="#ConstantDeclarations">Constant Declarations</a><br/>   
  <a href="#ControlStatements">Control Statements</a><br/>   
  <a href="#MethodCalls">Method Calls</a><br/>    
  <a href="#MethodDeclarations">Method Declarations</a><br/> 
  <a href="#BuiltinMethods">Built-in Methods</a><br/> 
  <a href="#DataPersistence">Data Persistence</a><br/>   
  <a href="#DataTypeDeclarations">Data Type Declarations</a><br/>    
</div>  
<div id="content_manual">
	<a name="Introduction"><h3>Introduction</h3></a>

			<p>
			This reference manual shows and explains relish&#8482; programming language constructs, starting from the most basic expressions and statements, and proceeding on to control constructs and beyond. Each construct is shown by one or more examples. Text after or interleaved with the examples explains the syntax rules and the semantics of the construct. <span class="future">language features planned but not yet implemented or enforced by the language compiler-interpreter or runtime environment are shown in text of this colour.</span>
			</p>
			<p>
				relish language constructs have simple syntax rules and minimal use of punctuation and brackets of various kinds. The language also has fewer reserved words than may be typical. However, the language achieves this simplicity and minimalism of expression by means of a trade-off; programmers must adhere to stricter rules than usual as to how and where each language construct is to be written in the program source text.
			</p>
			<p>
				Because of these strict syntax and code layout rules, it is strongly suggested that you begin creating relish programs, when you are first learning the language, by copy-pasting examples of language constructs from tutorials, example programs, code recipes, or from this manual. 
				The examples will be formatted and laid out correctly, and you can modify the code to your needs from that starting point, and learn the conventions as you go.
			</p>

	<a name="Variables"><h3>Variables</h3></a>		
    <code>
    a  b  c  a1  source240v  amount lineWidth  stateOfPlay  line1Length  bitWidth32  
    </code><br/><br/>
    Usage in context:<br/><br/>
    <code>
    a = 2<br/>
    lineWidth = a
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Variable names are camel-case latin-1 alphanumeric beginning with a lower case letter.
Digits count as lower case letters in the camel-case rule, except are not allowed as the first character of the name as
a whole, nor as the first character of any lower case word after an upper case letter. So theWord2 is allowed but theW2 is not.
The name as a whole cannot end with an upper case letter. Multiple upper case letters together are not permitted.
Note that underscores are not permitted (since they are an alternative to camel-case word separation.)    	
    </p>
<p>
Some names of this form may not be used as variable names:
<ul>
<li>the relish language's reserved words are excluded,</li>
<li>the name of any method visible in the scope,</li>

<li> the last name-part of any unaliased imported package,</li> 
<li> the package alias of any aliased imported package,</li> 
<li><span class="future">a name of a parameter of the containing method is already implicitly defined as a strictly typed variable in the method so may not be re-assigned to a value-type incompatible with the parameter's type specification.</span></li>	
</ul>
</p>

        <p>
    	<b>Semantics:</b>
    </p>
    <p>
	A variable is a named and re-assignable store for a value of an expression. The variable can be used as an expression, and yields the value that is stored in it at the time it is used as an expression. All variables are local variables inside a <a href="#Methods">method</a> body. 
	Variables are created by their first use in a method body. If the value assigned to a variable is a structured object or a collection, then the assignment is by reference, not by value-copy. Simple primitive values such as Int, Float are assigned by value.
    </p>
	

	<span class="future">The type of a variable is not stated explicitly when defining the variable. If you assign to a variable in multiple places inside a method body, the known types of the values assigned in the different places must form a type hierarchy. That is, if values of different known types are
	assigned in different assignment-occurrences, then at least one of those known types must be a common supertype of all the others. The type of the variable is then taken to be that common supertype of the known types of values assigned to it in the various assignment occurrences in the method. 
    </span>





	<a name="ReservedWords"><h3>Reserved Words</h3></a>		
    <code>
    if elif else while for in as break continue of go func true false nil
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>    
    <p>
The reserved words may not be used as variable names, method names, or package name parts or aliases. They are reserved for use to define control constructs and literal values in the language.
</p>


	<a name="Constants"><h3>Constants</h3></a>		
    <code>
    PI  E  MAX_WIDTH  LIMIT1  DIM1_SIZE 
    </code><br/><br/>
    Usage in context:<br/><br/>
    <code>
    PI = 3.1415926535<br/>
    DEFAULT_GREETING = "Hello, World!"
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Constant names are all-capitalized latin-1 alphanumeric, with single-underscore word separators permitted.
They must begin with a latin-1 capital letter.
Note: All single latin-1 capital letters except T denote constants. T,T1,... denote <span class="future">type parameters (See below.)</span> 	
    </p>
    <p>
    Constants must be defined at the top-level scope of a source code file. They cannot be defined within a method body.
    Constants are visible throughout the package in which they are defined. If their name is referred to inside a package that imports
    the constant-defining package, and if the constant name has been package-qualified in that use, the constant is visible
    in the package that imports the constant-defining package. <span class="future">However, if a constant is defined within the __private__ section of a source code file, its name is never visible outside the defining package.</span>
    </p>
        <p>
    	<b>Semantics:</b>
    </p>
    <p>
    	A constant can (and must when introduced) be assigned the value of an expression once, and thenceforth refers to that value.
    	<span class="future">There must be a restriction on the kind of expressions that can be assigned to constants, due to timing of the execution of the constant assignment statements, but what is that restriction?
    		When in the code load and generation and initialization sequence does the constant expression get evaluated??? Does this need to be changed to move the execution until all the methods etc are properly loaded into the runtime?</span>
	</p>



	<a name="DataTypes"><h3>Data Types</h3></a>		
    <code>
    Int32  Float  String  ClosedCurve  BuggyWhipStorageRackClip    	
    </code><br/><br/>
    Usage in context:<br/>
<code><pre>
add a Float b Float &gt; Float
"""
 A method that adds two floating-point numbers together and returns the result.
"""
</pre></code>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Type names are camel-case latin-1 alphanumeric beginning with an upper case letter.
All data type names must begin with at least two letters (upper case followed by lowercase.)
Other details of the name syntax are the same as for variables except for the initial upper case letter for type names.
Note that underscores are not permitted (since they are an alternative to camel-case word separation.)	
    </p>
    <p>
    Data types must be defined at the top-level scope of a source code file. They cannot be defined within a method body.
    Type names are visible throughout the package in which they are defined. If their name is referred to inside a package that imports
    the type-defining package, and if the type name has been package-qualified in that use, the type is visible
    in the package that imports the type-defining package. <span class="future">However, if a data type is defined within the __private__ section of a source code file, its name is never visible outside the defining package.</span>
    </p>
        <p>
    	<b>Semantics:</b>
    </p>
    <p>
    	Each data object/value in a relish program has a data type. The data type of an object/value determines which methods can accept the object/value as an argument, and which methods can return the object/value as one of the method's return values.
	</p>
	<p>
		Data types in relish can inherit attributes and method compatibility from other data types. A data type can inherit from more than one direct supertype. That is, relish has multiple inheritance.
	</p>
	<p>
		Data types are of three kinds, primitive value types, structured object types, and collection types.
	</p>
	<p>
		Primitive value types are such types as Int and Bool and <span class="future">Rune (unicode character)</span>.
	</p>
	<p>
        Structured object types are like the familiar "object classes" of other languages.
        A structured object type is defined by specifying a list of attribute specifications to define the attributes of the object.
        See "data type definition" section for details.        

    <p>
        Collection types are types such as List of T, Map of T T1, Set of T and have element accessing and iterating syntax support in the language, as well as compact syntax support for adding and deleting elements, if the collection is mutable. 
		<span class="future">String may be considered an immutable collection type.</span>
	</p>
	<p>
		<span class="future">Generics: - why are generics always "future" :-(  Data type definitions and type specifications may be parameterized; that is, the type may be defined as a wrapper or holder of objects/values of one or more other data types. For example, BinaryTreeNode of T T is a parameterized data type where the type parameter T stands for any other data type. Each parameterized data type definition effectively creates a set of possible data types, and each parameterized data type specification accepts a set of possible datatypes.</span>
	</p>	
	<p>
		In general, in relish, a data type (or class) does not "own" a set of methods.
		It is more accurate to say that an <b>n-tuple</b> (e.g. an ordered-pair, an ordered triple) of data types in relish owns a set of methods; the n-tuple of types conceptually owns those methods whose parameter signature (of all positional-argument input parameters) is that type tuple.</p>
		<p>
		Methods do not have a privileged argument object which is known as the receiver of the method call.
		Rather, all objects that are (required positional) arguments are the receivers of the method call, and relish's dynamic method dispatch will take account of the actual specific data type of each of the positional argument objects supplied to the call, to decide which method has a parameter type-signature that is the most specifically matching the tuple of argument objects.
     		</p>
		<p>A data type (or class) in relish can only be said to own 1) unary methods whose only input parameter is specified to be of that type, <span class="future">and also 2) special attribute-setter methods which set the values of attributes of a structured data object.</span>
	</p>





		<a name="TypeParameters"><h3><span class="future">Type Parameters</span></h3></a>		
	    <code>
	    <span class="future">T  T1  T2  T3  T4  T5  T6  T7  T8  T9</span>
	    </code><br/><br/>
	    <span class="future">Usage in context:<br/></span>
<code><pre>
<span class="future">LinkedList of T</span>	   
</pre></code>
	    <p>
	    	<span class="future"><b>Syntax:</b></span>
	    </p>
	    <p>
<span class="future">Relish supports parameterized data types (generics) and
	only the names above are valid as type parameters in 
	parameterized type declarations.</span> 	
	    </p>
	   


			<a name="InbuiltDataTypes"><h3>Inbuilt Data Types</h3></a>	
			
			<p>In the following, Type1 &lt;: Type2 denotes that Type1 is a subtype that inherits behaviour from and extends the definition of the supertype Type2</p>	
		    <code><pre>
Any                              (implicit) Abstract supertype of all relish datatypes
RelishPrimitive &lt;: Any           Abstract supertype of all inbuilt primitive data types in relish

Numeric &lt;: RelishPrimitive       Abstract supertype of all primitive number types
Integer &lt;: Numeric               Abstract supertype of all integer types
Int &lt;: Integer                   64-bit signed integer
Int32 &lt;: Integer                 32-bit signed integer<span class="future">
Int16 &lt;: Integer                 16-bit signed integer
Int8 &lt;: Integer                  8-bit signed integer</span>
Uint &lt;: Integer                  64-bit unsigned integer
Uint32 &lt;: Integer                32-bit unsigned integer<span class="future">
Uint16 &lt;: Integer                16-bit unsigned integer
Byte &lt;: Integer                  8-bit unsigned integer
Bit &lt;: Integer                   1-bit unsigned integer</span>
Bool &lt;: RelishPrimitive          Boolean logical type (true,false)
Real &lt;: Numeric                  Abstract supertype of all floating-point numeric types
Float &lt;: Real                    64-bit floating-point number<span class="future">
Float32 &lt;: Real                  32-bit floating-point number
ComplexNumber &lt;: Numeric         Abstract supertype of all complex numeric types
Complex &lt;: ComplexNumber         Complex number consisting of two 64-bit Float parts
Complex32 &lt;: ComplexNumber       Complex number consisting of two 32-bit Float32 parts

Text &lt;: RelishPrimitive          Abstract supertype of all text data types
CodePoint &lt;: Text                A 32-bit unsigned integer representing a Unicode codepoint</span>	 
String &lt;: Text                   immutable byte-array representing UTF-8 encoded CodePoints.<span class="future">			
Callable &lt;: RelishPrimitive      Abstract supertype of all function types
MultiMethod &lt;: Callable          A set of methods in a namespace that share the same name
Method &lt;: Callable               An executable function implementation

NonPrimitive &lt;: Any              Abstract supertype of any type which is not a RelishPrimitive             
Struct &lt;: Any                    Abstract supertype of programmer-defined structured object types
Collection of T &lt;: Any           Abstract supertype of collection classes e.g. List Set Map
List of T &lt;: Collection of T     Collection which maintains elements in a sequence
Set of T &lt;: Collection of T      Collection which holds at most one of each value
Map of T1 T2 &lt;: Collection of T1 Map from one data type to another 

InChannel &lt;: Any                 A channel which can be read from
OutChannel &lt;: Any                A channel which can be written to
Channel &lt;: InChannel OutChannel  A channel which can be read from and written to</span>
</pre></code>
<p><span class="future"><em>Some issues here. Should Struct and Collection and Channel be NonPrimitive? </em></span></p>
		   






  <a name="LiteralValues"><h3>Literal Values</h3></a>    

<h4>Integer literals</h4>
    <code>
    42<br/>
0600<br/>
0xBadFace<br/>
170141183460469231731687303715884105727<br/>  
<span class="future">-42<br/>
-0600<br/>
-0xBadFace<br/>
-170141183460469231731687303715884105727<br/></span>
    </code><br/>
    Usage in context:<br/><br/>
    <code>
    a = 42<br/>
    color = 0xFFCADD<br/>
    <span class="future">n = plus -42 260<br/></span>
    </code>
    <p>
An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0 for octal, 0x or 0X for hexadecimal. In hexadecimal literals, letters a-f and A-F represent values 10 through 15. An optional negation prefix - (which if present must come before the non-decimal base prefix) negates the value represented by the sequence of digits. The negation prefix cannot appear in a literal whose value is 0
    </p>


<h4>Floating-point number literals</h4>

<code><pre>
0.
0.0
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
<span class="future">-72.40
-072.40  // == -72.40
-2.71828
-1.e+0
-6.67428e-11
-1E6
-.25
-.12345E+5</span>
</pre></code>
    Usage in context:<br/><br/>
    <code>
    PI = 3.14159265357989<br/>
    r = 6.67428e-2<br/>
    <span class="future">p = -1.7<br/></span>
    </code>
    <p>
A floating-point literal is a decimal representation of a floating-point constant. It has an integer part, a decimal point, a fractional part, and an exponent part. The integer and fractional part comprise decimal digits; the exponent part is an e or E followed by an optionally signed decimal exponent. One of the integer part or the fractional part may be elided; one of the decimal point or the exponent may be elided.  An optional negation prefix - negates the value represented by the sequence of digits. The negation prefix cannot appear in a literal whose value is 0.
</p>

<h4>Boolean literals</h4>

<code><pre>
true  false
</pre></code>
Usage in context:<br/>
<code><pre>
DEBUG = false

while true
   doSomethingForever
</pre></code>
    <p>
Boolean literals represent the boolean logic values true and false, which are the only two values of inbuilt data type Bool. 
false is the zero-value of the Bool type.  
</p>
<p>
NOTE: In relish, the zero-value of any data type is considered false-equivalent in logical tests (as in "<b>if</b>" "<b>while</b>" "<b>for</b>") and is also considered false-equivalent in the Boolean logic operator functions "<b>and</b>" "<b>or</b>" and "<b>not</b>". nil (non-present non-primitive object) is also considered false.
</p>
So values that test false or act as false in boolean operator functions are:
<pre>
0
0.
false
[]   // empty list
{}   // empty set
{=>} // empty map
""   // empty string
nil
</pre>
All other values of any data type test non-false, and act non-false in boolean operator functions.
</p>


<h4>String literals</h4>

<code><pre>
"Hello, world!\n"  
"\n"
""
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"       // illegal: surrogate half
"\U00110000"   // illegal: invalid Unicode code point

These examples all represent the same string:

"日本語"                                 // UTF-8 input text
"\u65e5\u672c\u8a9e"                    // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // the explicit UTF-8 bytes

A multi-line raw string:

      """
"""   
It was a dark and stormy night.
I had a premonition that I should not keep
writing this long, overwrought, badly formatted, 
and turgidly melodramatic story,
but I couldn't help myself. "Damn!", I said to myself,
this is the end.
"""
</pre></code>
    Usage in context:<br/>
<code><pre>
   firstName = "Jeremiah"
   aphorism = """
"""
No matter where you go,
There you are!
And notice that where I am
is starting at the first column
of the source code file.
But then notice that indentation resumes after me, as if I
weren't present in the source file.
"""
   lastName = "Jones"
   truism = """
"""
Stupid is as
stupid does.
"""   
   age = 9

</pre></code>
    <p>
Strings in relish (currently) exhibit and behave much as string values do in Go, because their underlying implementation is a Go string. 
</p>
<p>
A String literal represents a String constant obtained from concatenating a sequence of characters. There are two forms: single-line interpreted String literals and multi-line raw String literals.
</p>
<p>
Interpreted String literals are character sequences between double quotes "". The text between the quotes, which may not contain newlines, forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \' is illegal and \" is legal), with the same restrictions. The three-digit octal (\nnn) and two-digit hexadecimal (\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \377 and \xFF represent a single byte of value 0xFF=255, while ÿ, \u00FF, \U000000FF and \xc3\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.
</p>
<p>
Multi-line raw String literals are character sequences between triple-doublequote delimiters. 
Within the delimiters, any character is legal. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the delimiters; in particular, backslashes have no special meaning and the string may contain newlines. Carriage returns inside raw string literals are discarded from the raw string value.
</p>
<p>
Because of the heavily indentation-dependent nature of relish source code, multi-line raw string literals are first introduced
in their proper indented location, by a single """. On the following line, there must be another """ at the beginning of the line.
The actual raw string value begins on the next line; the one after the second """. 
The raw string continues until the next (third) """, which must again occur at the beginning of a line of the source code file.
So raw strings are always multi-line. Raw string literal values do not include the initial newline character, but do include the last newline character.
The shortest possible multi-line raw string is 
<pre>
   s = """
"""
"""
</pre>
Which is equivalent to the interpreted string literal "\n". 
</p>
</p>
<p>
One peculiarity of Go strings is that their index operator returns a byte at the ith byte position, whereas the string is fundamentally supposed to be a 
sequence of utf-8 encoded unicode codepoints. Each codepoint, utf-8 encoded, can occupy multiple bytes of the string. Also, disturbingly, the len function of a Go string returns the number of bytes, not the number of unicode codepoints in the string. I don't really like these split-personality
grudgingly unicode behaviours of Go strings, but relish Strings are stuck with them for now.
</p>


	<a name="AssignmentStatements"><h3>Assignment Statements</h3></a>		
    <code><pre>
a = 9

bigBigVariableName = 
   "A very very very very very very very very very long value might have to be on the next line, indented."

a b c = d "something" f

a b c = 9432
        "a string"
        d 

a b c =
   d
   143.65
   f    

obj1.obj2.obj3.a = 143.65

myList[3].myMap["Joe Bloggs"].a[i] = "3155 Kent Street"

coord[0].lat = 49.5
    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
An assignment statement consists of one or more assignable left-side-expressions, followed by the assignment operator "=" followed by one or more expressions that (collectively) must produce the <em>same number</em>** of values as the number of assignable left-side expressions. The "=" must be preceded by a single space. If the right-side expressions are on or begin on the same line as the "=", the ""=" must be followed by a single space, which is followed by the beginning of first right-side expression.
</p>
<p>
The left-side expressions must be simple enough to fit on one-line. The second and subsequent left-side expressions, if any, must be separated from their predecessor by a single space. A Left-side expression must be one of:
<ol>
	<li>A local variable or method parameter in a method body.</li>
	<li>An attribute of a structured object.  
	<li>An indexed position in an ordered collection or a map, specified by <expr>[i] or <expr>[key].
	<li>A path of expressions separated by the infix "." operator. The first expression must be a local variable, method parameter, or an indexed position in a collection/map-valued variable or parameter.  Each subsequent expression in the path may be the name of a unary function, an attribute, or an attribute-getter-function, or may be an indexed position in the value returned by one of these. 
</ol>
</p>
<p>
The right-side expressions may appear in several spatial configurations in the source code file.
<ul>
<li>The first configuration is in-line on the same line as the left side and the " = ". In this configuration, if there are multiple expressions, they must be simple so it is not ambiguous where one expression ends and the next begins. Each of the multiple expressions on the line must be one of a) a simple literal, b) a variable name, c) an index expression, dot-notation expression, or combination thereof, or d) a method call enclosed in brackets (foo a "b"), where the method call itself has only simple literals, variable names, index expressions, or dot-notation expressions as arguments. </li>
<li>The second configuration is multiple right side expressions stacked one below the other, starting with the first right-side expression in its normal in-line position one space to the right of the "=" operator. </li>
<li>The third configuration is one or more right-side expressions stacked one below the other, starting on the line following the left-side expressions and " =". In this case, the right-side expressions must all be indented one indent level from the indent position of the beginning of the assignment statement as a whole. </li>
</ul>
</p>
<p>
**There is one exception to the rule that the right-side expressions must produce the same number of values as the number of l-expressions. The right-side may consist of a single expression which evaluates to an ordered collection (e.g. a list or ordered set) containing exactly the same number of elements as the number of l-expressions. 
</p>
</p>
<p>
<b>Semantics:</b>
</p>



<p>
<span class="future">Restrictions apply that limit which assignments are legal, based on type compatibility considerations and on writeability permissions of object attributes and collections. </span>
</p>
<p>
<span class="future"><em>In the following, the term "the statically known type" of an expression refers to the most specific data type that it can be assumed applies to the expression, based on compile-time type information, lexical program structure, and type inference.</em> </span>
</p>
<dl>
<dt>Assigning to a local variable</dt>
<dd><span class="future">Inside a method body, you can assign a value to a variable. The first encountered assignment implicitly creates the variable. There may be multiple lexical occurrences of assignment to the same variable in the method body. The variable is (implicitly) assigned a type constraint; the (most general) statically known type of the values assigned to it among the different lexical assignment occurrences.
<br/>
	There is a type restriction on assignments to the same variable within a method body: There must exist a statically known type among those of the values assigned to the variable which is a supertype of (or the same as) all of the other statically known types of values assigned to the variable in the method body. </span></dd>	
<dt>Assigning to a parameter of a method</dt>
<dd><span class="future">Inside a method body, you can assign a new value to a parameter of the method. Method parameters are declared with a data type specification. The value you assign to the parameter must be compatible with (same as or a subtype of) the type specified for the parameter.</span></dd>

<dt>Assigning to an attribute of a structured object</dt>
<dd><span class="future">You can assign a value to an attribute of an object. Object attributes are declared with a data type specification. The value you assign to the attribute must be compatible with (same as or a subtype of) the type specified for the attribute. 
<br/>
<!-- Some attributes are flagged as not writeable, or not writeable in certain contexts. Blah blah blah. -->
</span></dd>

<dt>Assigning to an indexed position in a collection or map</dt>
<dd><span class="future">You can assign a value to a position in a mutable ordered collection or a mutable map, or to a position in an ordered multi-valued attribute. Collections, maps, and multi-valued attributes are declared with an element data-type specification. The value you assign to the position in the collection/map/multi-valued attribute must be compatible with (same as or a subtype of) the element data-type specification. 
<br/>
<!-- Some collections are immutable. Blah blah blah. -->
</span></dd>
</dl>











	<a name="ConstantDeclarations"><h3>Constant Declarations</h3></a>	
<!-- PI Float32 = 3.14159265357989 -->		
    <code><pre>
PI = 3.14159265357989

E = 2.17  // or roughly anyway

MAX_WIDTH = 1024
    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
A constant declaration consists of a constant name, followed by the assignment operator "=" followed by an expression. The "=" must be preceded by a single space. If the right-side expression is on or begins on the same line as the "=", the ""=" must be followed by a single space, which is followed by the beginning of the right-side expression.
</p>
<p>
The right-side expression may appear in several spatial configurations in the source code file.
<ul>
<li>The first configuration is in-line on the same line as the left side and the " = ".  </li>
<li>The second configuration has the right-side expression starting on the line following the constant name and " =". In this case, the right-side expression must all be indented one indent level from the indent position of the beginning of the constant declaration. </li>
</ul>
</p>
<p>
A constant declaration can only appear at the top-level lexical scope in a source code file. That is, it must begin in the 1st column of the source code file. It may not occur inside a method body or type declaration.
</p>
</p>
<p>
<b>Semantics:</b>
</p>
<p>
A constant can only be assigned a value once, at its declaration. The name then represents that value and can be used as the value in an expression.
Constant names are exported from the package in which they occur <span class="future">unless they are declared within the __private__ section of a source code file, in which case they are only visible within the package.</span>
</p>



	<a name="ControlStatements"><h3>Control Statements</h3></a>	
	
	<h4>"if" conditional</h4>
    <code><pre>
	
if lt x 0
   x = neg x

if lt x 0
   x = 0
else
   x = 1
	
if some
      condition
      expression
   statement
   statement
elif another condition
             expression
   statement
   statement
   statement
elif aThird condition expression
   statement
else
   statement
   statement
    </pre></code>
<p>
<b>Semantics:</b>
</p>
<p>
If the test expression evaluates to any non-false value, the immediately following indented clause (statement sequence) is	executed,
otherwise control passes to the next elif test if present, or to an else clause if only that is present, or to the statement following the "if", if neither another elif or an else are present.
If none of the if or elif tests pass, and an else is present, its indented clause (statement sequence) is executed.
</p>
<p>
"if" is a statement but not an expression. It does not return a value.
</p>

	<h4>"while" loop</h4>
    <code><pre>
while neq (location cows) home
   herd cows	
   sleepRough
   drink COWBOY_COFFEE
	
while some
         condition
         expression
   statement
   if condition
      break
   elif condition2
      continue
   statement
elif another condition
             expression
   statement
   statement
elif aThird condition expression
   statement
else
   statement
   statement
    </pre></code>
<p>
<b>Semantics:</b>
</p>
<p>
While the test expression evaluates to any non-false value, the immediately following indented clause (statement sequence) is executed, then the 
test expression is evaluated again, and so on.
</p>
<p>
"while" is a statement but not an expression. It does not return a value.
</p>
<p>
A while conditional can optionally include alternative clauses (elif,else). The alternative clauses are tested/invoked only if the while condition is false initially (i.e. if the loop is not entered).
</p>

  <h4>"break" statement</h4>
  <p>
    A "break" statement may occur inside the statement sequence body of a "while" loop or "for" loop. If it is executed, the break statement
    causes execution to immediately resume at the first statement after the "while" or "for" loop.
  </p>
  <p>
    The break statement accepts one optional positive integer argument, which is the number of containing loops to break out of.
    If the argument is omitted, it is equivalent to "break 1".
  </p>
  <code><pre>
while true
   while someOtherCondition
      if tired
         break 2
      doMoreWork
   print "Hello"
print "Finally done."

// If the tired condition becomes non-false, execution resumes outside both loops, 
// and "Finally done." is printed without another "Hello"   
  </pre></code>

  <h4>"continue" statement</h4>
  <p>
    A "continue" statement may occur inside the statement sequence body of a "while" loop or "for" loop. If it is executed, the continue statement
    causes execution to skip over the rest of the statements in the statement sequence body of the loop, and return to the top of the loop; that is, the next thing to execute will be the "while"'s test again, or the "for"'s increment statement or increment-then-test.
  </p>
  <p>
    The continue statement accepts one optional positive integer argument, which is the number of containing loops to jump to the top of the next iteration of.
    If the argument is omitted, it is equivalent to "continue 1".
  </p>	
  <code><pre>
while someCondition
   print "Hello"
   while someOtherCondition
      if tired
         continue 2
      doMoreWork
      print "Working on the railroad."
   print "Goodbye"
print "Finally done."

// If the tired condition becomes non-false, execution resumes at the next test of someCondition 
// and if that is non-false, "Hello" is printed before another "Working on the railroad." and before another "Goodbye"  
  </pre></code>  


<h4>"for" loop</h4>
    <code><pre>

// "for" forms that iterate over a collection <span class="future">or map</span>, 
// setting an index<span class="future">/key</span> variable and/or an element value variable 
// to refer successively to each (position and) element in the collection<span class="future">/map</span>.

for i val in someList<span class="future">OrOrderedSet</span>
   statement
   statement

for i val        
   in 
      someList<span class="future">OrOrderedSet</span>
   statement
   statement
<span class="future">
for key val in someMap  
   statement
   statement

for key val        
   in 
      someMap
   statement
   statement   
</span>
for val in someList<span class="future">OrSet</span>
   statement
   statement
<span class="future">
for key in someMap  
   statement
   statement   

for i key val in someOrderedMap  
   statement
   statement

// for an ordered map, the val is the key in this case</span>
for i val1 val2 in someList<span class="future">OrOrderedSetOrOrderedMap</span> someOtherList<span class="future">OrOrderedSetOrOrderedMap</span> 
   statement
   statement

<span class="future">// The val variables are assigned the zero-value of the type 
// when their collection is exhausted before other collection(s).</span>

for i val1 val2 val3                             
   in 
      someList<span class="future">OrOrderedSetOrOrderedMap</span>       
      someOtherList<span class="future">OrOrderedSetOrOrderedMap</span>   
      someThirdList<span class="future">OrOrderedSetOrOrderedMap</span>
   statement
   statement


for val1 val2 in someList<span class="future">OrOrderedSetOrOrderedMap</span> someOtherList<span class="future">OrOrderedSetOrOrderedMap</span>
   statement
   statement      


<span class="future">      
// Traditional C-style "for" loop incrementing and testing index variables

for i = 0 
    less i n
    i += 1
   statement
   statement

for i j =
       min a b
       min c d
    and less i m
        less j n
    i += 1
    j = calcJ i
   statement
   statement

for i = 0   less i n   i += 1  // one-line 3-spaces-separated form allowed if a single index-variable
   statement
   statement</span>
    </pre></code>
<p>
<b>Semantics: "for" iteration over one or more Collections/Maps</b>
</p>
<p>
Iteration proceeds from the lowest-indexed to highest-indexed element of an ordered collection or ordered map. The single-variable form of "for" can iterate over an unordered set (or unordered map), and returns the elements (keys) in unspecified order.
</p>
<p>
IMPORTANT NOTE: "for" iteration is <b>not thread-safe</b>. <span class="future">You need to lock explicitly to ensure exclusive access while iterating, if multiple go-routines may modify the collection/map.</span>  
</p>
<p>
IMPORTANT NOTE: The behaviour of "for" iteration over collections/maps which are being modified (by the same or another go-routine) during the iteration is <b>undefined</b>. That means you should never attempt it. It may or may not cause a panic, but even if it does not, the execution sequence and index and value variable settings are undefined and cannot be relied on.</span>  
</p>
<p>
<b> <span class="future">Semantics: "for" with index incrementing and test expressions</span></b>
</p>
<p>
   <span class="future">TBD</span> 
  </p>


  <a name="MethodCalls"><h3>Method Calls</h3></a>   
    <code><pre>
<span class="subtle">1.</span> foo 19 "fast" body.arm[1].elbow.angle[2]

<span class="subtle">2.</span> foo (bar 253 c d[2] a.b) "fast" (calculateAngle opp adj)

<span class="subtle">3.</span> positionAndStamp envelope 
                    rubberStamp

<span class="subtle">4.</span> positionAndStamp
      envelope
      fetchAppropriateStamp rubberStampBox "PAID"                

<span class="subtle">5.</span> positionAndStamp
      envelope
      fetchAppropriateStamp 
         rubberStampBox 
         "PAID"        

<span class="subtle">6.</span> print times 2 PI

<span class="subtle">7.</span> print times 2 
               PI

<span class="subtle">8.</span> print times
            2
            PI

    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
Method names have the same syntax as variable names, method-parameter names, structured-object attribute names<span class="future">, and relation-end names</span>. In relish, you must use contextual information (where they appear in the program, how they are juxtaposed with other program elements, and whether a variable or parameter or attribute <span class="future">or relation-end</span> name has been explicitly defined in the scope) to distinguish the two. <b>Aside on Language philosophy:</b> This conflation of the names of named values (e.g. variables, attributes) and the names of functions, which supply values, is deliberate. It promotes object-oriented data hiding, in that the syntax for getting and setting the values of object attributes is identical to the syntax for calling getter and setter methods. The syntax for calling a unary function of an object is also identical to the syntax for getting the value of an attribute of the object. Therefore, the implementor of the object's data type (class) is free to substitute a computed function for an explicitly stored attribute, or vice versa, without requiring change in code that uses the object.
</p>
<p>
A method call consists of the name of the method followed by zero or more argument expressions. There are three allowed spatial configurations of the arguments in the source code:
<ul>
<li>The first configuration is in-line on the same line as the method name, as shown in examples 1. and 2. above. In this configuration, if there are multiple argument expressions, they must be simple so it is not ambiguous where one expression ends and the next begins. Each of the multiple expressions on the line must be one of a) a simple literal, b) a variable name, c) an index expression, dot-notation expression, or combination thereof, or d) a one-line method call which itself has only simple literals, variable names, index expressions, or dot-notation expressions as arguments. </li>
<li>The second configuration is multiple argument expressions stacked one below the other, starting with the first right-side expression in its normal in-line position one space to the right method name, as shown in example 3. above. </li>
<li>The third configuration is one or more argument expressions stacked one below the other, starting on the line following the method name, as shown in examples 4. and 5. above. In this case, the argument expressions must all be indented one indent level from the indent position of the beginning of the method call as a whole. </li>
</ul>
There is one concession to concise expression of a common case; that where a method's single argument is another method call that consumes all remaining arguments. See examples 6., 7., and 8.
In this case, the argument method call can be expressed without being surrounded by round brackets or indented onto the next line.
This form is not allowed if the top-level method requires another argument beyond the value(s) the argument method call returns. 
</p>


<p>
<b>Semantics:</b>
</p>
<p>
A method call first evaluates all of its argument expressions, in left-to-right order. Multiple methods may share the same method name, so multiple dispatch (multimethod dispatch) is performed to choose which method to execute. Once a method is chosen, the argument values are assigned to the method parameters, and the method body statements are executed in sequence until the end of the statement block is reached or a return statement ( "=>" statement in relish ) is encountered. The number of values specified in the method's declaration are returned to the calling context, which may assign those values in an assignment statement, may use them as arguments to another expression or statement, or may discard them. All methods sharing a name (within a package import hierarchy) must be declared to return the same number of values, which may be from 0 to 9 return values.  
</p>
<p>
    <code><pre>
radius theta = polar x y</pre></code>
The polar method (more precisely the polar multimethod i.e. the set of methods sharing that name) has been declared to return 2 values, which are assigned to the radius and theta variables in the calling context.
</p>   
<p>
    <code><pre>
x1 y1 = cartesian polar x y</pre></code>
The cartesian multimethod has been declared to accept two arguments, which the polar method call supplies.
</p>
<p>
    <code><pre>
<span class="future">radius _ = polar x y</span></pre></code>
<span class="future">The calling context only cares about the radius return value and ignores the angle return value by assigning it to the anonymous dummy variable _ .</span>
</p> 
<p>
    <code><pre>
send "message"</pre></code>
The send multimethod, we will suppose, has been declared to return an error status value, but the programmer of the calling context, unwisely, has chosen to silently ignore it.
</p> 






<h4>Multiple Dispatch</h4>
<blockquote>
Multiple dispatch or multimethods or function overloading is the feature of some object-oriented programming languages in which a function or method can be dynamically dispatched based on the run time (dynamic) type of more than one of its arguments. This is an extension of single dispatch polymorphism where a method call is dynamically dispatched based on the actual derived type of the object on which the method has been called. Multiple dispatch generalizes the dynamic dispatching to work with a combination of two or more objects. -- <em>Wikipedia</em>
</blockquote>

<p>
  In a relish package, a given method name may be the name of multiple methods, which may be defined in the current package, in a package directly imported by the current package, or in a package imported directly or indirectly by a directly imported package. The set of such methods, as seen from within a given package, is called the multimethod (of a given name.)
</p>
<p>
When there is a method call, a single method (of the multimethod) must be chosen by the relish runtime environment as the method that will be applied to the arguments and executed. This choice is made by a process of pattern matching the parameter type signature of each method against the run time (dynamic) type of each required positional argument that has been supplied in the method call. 
</p>
<p>
 The following is a description of the multi-argument dynamic method dispatch process used by relish.
 Bear in mind when informally assessing its performance that the full dispatch process is only executed once per program-run
 for a given type-tuple of arguments applied to a given method. Subsequent calls with the same tuple of types of arguments
 take advantage of a type-signature-match cache which selects the method using a single hashtable lookup. 
</p>
<p>
  The elevator-pitch version of the multiple dispatch process:
  <ul>
   <li>Find methods of the multimethod whose parameter type signature is compatible with (same as or a generalization of) the run time (dynamic) types of the actual arguments in the method call.</li>
   <li>From those, choose the method whose parameter type signature is closest in types to the types of the arguments.</li>
   <li>If there is a tie, assess the type signatures of the candidate methods against each other, to determine which method's type signature is
    more specific in an absolute sense in the type-lattice (the ontology) of data types in the program. Pick that method.</li>
 </ul>
</p>
<p>
  Here is the lengthier, more precise description of the multiple dispatch process:
  <ul>
   <li>Find those method implementations of the multimethod whose parameter-type
   signature is the same as or a generalization of the type-tuple of run time (dynamic) types of the actual argument objects/values.
   </li>
   <li>Select from the type-signature-compatible methods the one whose parameter type signature is the minimal Euclidean distance
   (in multi-dimensional type specialization space) from the type-tuple of the run time (dynamic) types
   of the actual argument objects. That is, select the method having the parameter-type-signature that is compatible with and minimally different in types from the argument run time (dynamic) types. Here the <em>method parameter type signature</em> and the <em>list of run-time (dynamic) types of arguments</em> are considered vectors (of length = the method arity) in multi-dimensional type-specialization space.</li>
  <li>If more than one method is equally close in type signature to the
   argument types (measuring Euclidean distance down the specialization paths),
   then the tie is broken by selecting the method whose signature is most specific
   in types compared to the top types in the ontology of data types in the program.</li>
   <li>If there is still a tie, the method which was encountered first (in the multimethod's
   list of methods of a particular arity) is chosen. This last choice is somewhat arbitrary but should almost never need to be invoked as ties in both the first matching criterion (type-tuple Euclidian distance from argument types) and second criterion (absolute specialization-lattice depth of method signature type-tuples) ought to be exceedingly rare.</li>
 </ul>
</p>




<h4><span class="future">"dot-notation" for calling single-parameter (unary) methods</span></h4>
<p>
<span class="future">Methods which accept only a single positional argument can (optionally) be called with "dot-notation" syntax:</span>
</p>
<code><pre>
<span class="future">a.foo</span></pre></code>
<span class="future">is equivalent to</span> 
<code><pre>
<span class="future">foo a</span></pre></code>
<span class="future">That is, call method foo on the argument a</span>
</p>
<p>
<span class="future">The dot-notation version can be used in some contexts where prefix calling is not allowed:
It can increase the depth of method-call nesting allowed in a single-line method call.</span>
<code><pre>
<span class="future">
bar a.b.c.foo "frap" d.e.baz</span></pre></code>
<p>
<span class="future">The dot-notation version of unary-method calling provides syntactic equivalence between object attribute access and getter-function
call and unary function call, allowing for object-oriented data encapsulation (data-hiding) without syntactic baggage.</span>
</p>







	<a name="MethodDeclarations"><h3>Method Declarations</h3></a>		
    <code><pre>
foo a Int b Int > Int
"""
 Adds a to b.
 The => is the return statement. It returns the value(s) of the expression(s) after it.
"""
   => add a b


divide a Int b Int > dividend Float err er.Error
"""
 Divides a by b. Returns an exception if b is zero.
 If one return argument is named, all must be named for consistency.
 <span class="future">If return arguments have been named, the return statement can
 occur without any expressions after it, and will cause execution to
 return from the function immediately. return arguments should already
 have been assigned to by this time, or they default to the zero/nil value 
 of their type.</span>
"""
   if eq b 0
      err = Error "Divide by zero!"   <span class="future">=>  // Three spaces precede in-line return statement</span>
   dividend = div a b


foo a Vehicle b Vehicle 
> Bool er.Error
"""
 This is a declaration of a method's interface, with no implementation.
 <span class="future">This is allowed, and results in a requirement that there exist 
 a method with an implementation to handle each possible subtype combination of the 
 input argument types.</span>
 This example was put here to show the variation in layout of the return values specification.
"""


divide a Int b Int 
> 
   dividend Float 
   err er.Error
"""
 Divides a by b. Returns an exception if b is zero.
 Again, just an interface declaration with no method body statements, put here
 just to show the variation in layout of the return values specification.
"""


divide 
   a Int 
   b Int 
> 
   dividend Float 
   err er.Error
"""
 Divides a by b. Returns an exception if b is zero.
 This example shows vertically indented input argument specifications.
"""
   err = zeroCheck b
   if err
      => nil
         err
   dividend = div a b
   => dividend
      nil

stamp p Passport
"""
 Stamps the passport with an entry stamp.
 This example shows the declaration of
 a method that does not return any values.
"""
   position p
   open p
   bangStamp p

doTheHokeyPokey
"""
 This method just does something. It has no input arguments or results returned. 
 Because it takes no arguments, it requires
 an implementation because being abstract does not make sense for it.
"""
   putInFoot "Left"
   putInFoot "Right"   


doTheHokeyPokey firstFoot String
"""
 This method just does something. It has 1 argument and no outputs. 
"""
   if eq firstFoot "left"
      secondFoot = "right"
   else
      secondFoot = "left"
   putInFoot firstFoot
   putInFoot secondFoot
    </pre></code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Method declarations start with the method name, which must occur at the top-level scope in a source code file. 
That is, the method name must be at column 1 of the file.	
    </p>
    <p>
The method name can be followed by zero or more input parameter declarations. Each input parameter declaration is a variable name, followed by a type specification. Input parameter declarations, if the type specifications are simple, can be laid out in-line on the same line as the method name, separated from each other by a space. Or they can be laid out one below the other, starting on the line below the method name, indented one level. This form allows for complex multi-line parameter type specifications.
    </p>
    <p>
      Following the input parameter declarations if any, there may occur the return value(s) declaration. This begins with a &gt;. If the return value(s) declaration is to be on the same line as the method name, the &gt; must follow the last input parameters declaration (or method name if no input parameters) by one space. In this case the return value declaration(s) must follow the &gt; after a space, and be single-space-separated from each other. Each return value declaration consists of an optional variable name then (space separated) a type specification.
    </p>
    <p>
      The return values specification may also occur on the line following the method name or the end of the input parameters, whichever is later.
      In this case, the &gt; must occur in column 1 of the file. The return value declaration(s) may then follow in-line on that line as described above,
      or may appear one below the other, starting on the line following the &gt; and indented one level from the &gt;.
    </p>
    <p>
      On the next line below the lowest of the method name, the input parameter declaration(s), or the return value declaration(s), there must appear a method header comment. This comment begins with """ at column 1 of the source code file, and continues until a terminating """ also at column 1 of the
      file. The text content of the comment must be indented by 1 space from column 1 of the file. i.e. The first comment line must begin at column 2, and subsequent text lines of the comment must begin at column 2 or greater.
    </p>
    <p>
      On the line following the method header comment, the method body statements must begin, if present. A method can be declared as just its commented header i.e. its interface declaration. Implementing methods must exist elsewhere to cover all subtype combinations of the declared input parameter types.
    </p>  
    <p>
      Method body statements must be laid out, one below the other, indented one level (3 spaces) from the column position of the method name and header comment.
    </p>
    <p>
       <span class="future">relish forces the factoring of method complexity, by allowing a maximum of 9 statements in the method body statement sequence. Nested constructs (ifs, loops) within that statement sequence can each also contain up to 9 statements in each clause. Also to this end, relish imposes a limit of 9 required positional input parameters for a method, and a limit of 9 result values per method. The input parameter limit can be worked around in two ways; by using keyword-style parameters, and by declaring a variadic parameter which will collect additional method-call arguments into a list.</span>
    </p>

<h4>"Return" statements</h4>
<p>
A return statement <b>=&gt;</b> causes a return from the currently executing method.
It may also specify the value(s) to return from the method.
    <code><pre>
   => "SUCCESS"

   => times 2 b  // returns the value of the times method-call.
  </pre></code>
If a method specified two return arguments, and did not name the return arguments (they were specified
with a type only), then the following form of return statement must be used:
    <code><pre>
   => a nil  // return two values, as long as a is a variable and not the name of a method that takes an argument.

   => a
      nil 

 <span class="future">//... or the following more vertically separated form, which looks better after a nested statement:

   doSomething
      someArg
      someOtherArg
   =>                 
      attr1
      98.6</span>
  </pre></code>
A method which specifies names for its return arguments cannot use the form of return statement that has arguments.
Instead, if a return value is to be set, the return argument must be assigned to within the 
subroutine body. Named return values which are not assigned to default to the nil/zero-value of the data type. 
Note that this zero-value defaulting ONLY works for named return args.

  <span class="future">If you want to specify an early return from a subroutine with named return args or no return args, 
you should use the =&gt; statement with no arguments. In this case only, the =&gt; statement may
appear on the same line as the end of the previous statement, separated from it by 3 spaces.</span>
    <code><pre>
<span class="future">
   if weNeedToGetOutOfThisMethod
      doSomeFinalCleanup arg   =>  // ...and exit
   moreMethodStuff here

   // or...

   if weReallyNeedToGetOutOfThisMethod
      doSomeFinalCleanup arg  
      =>  // ...and exit
   moreMethodStuff here</span> 
 </pre></code>

		<a name="BuiltinMethods"><h3>Built-in Methods</h3></a>	
		<p>
			relish currently comes with a small but growing number of standard built-in methods. These methods are available from within any package without having to import a package containing the methods. The general plan is that a small number of these methods, the most general purpose, will remain implicitly-imported, but that others will migrate into relish standard library packages, and will have to be imported and their names package-qualified to be used. The plan is to (eventually) lift many of Go's standard libraries into relish, using shallow wrapper methods.
			</p>
			<p>
				Here is the current list of built-in standard methods.
		</p>	
	    <code><pre>
		
// Comparison operators
		
eq RelishPrimitive RelishPrimitive > Bool
"""
 Returns whether two primitive-type values are equal in value.
 Currently, applies to Numeric,String,Bool.
 Converts between numeric types if necessary before testing for numeric equality, 
 and converts a number to its string representation to compare with a string.
"""

lt a Numeric b Numeric > Bool 
"""
 Numeric less-than operator.
"""

lt s1 String s2 String > Bool
"""
 Lexicographical less-than operator. Compares two strings.
"""

gt a Numeric b Numeric > Bool
"""
 Numeric greater-than operator.
"""

gt s1 String s2 String > Bool
"""
 Lexicographical greater-than operator. Compares two strings.
"""


// Boolean logic operators

not a Any > Bool
"""
 Boolean logical negation operator. Any non-false object/value passed in results in false.
 Any false-equivalent object/value passed in results in true.
"""

and ...a Any > Any
"""
 Boolean logical and operator. If any of its arguments are false-equivalent, returns false,
 otherwise returns the last argument.
 All arguments are evaluated, unlike LISP's lazy and operator.
"""

or ...a Any > Any		
"""
 Boolean logical or operator. Returns the left-most of its arguments which is non-false.
 If all arguments are false-equivalent, returns false.
 All arguments are evaluated, unlike LISP's lazy or operator.
"""
		
		
// Arithmetic operators		
		
times a Numeric b Numeric > Numeric
""" 
 Return value type is covariant with argument types.
"""

div a Numeric b Numeric > Numeric
""" 
 Return value type is covariant with argument types.
"""

mod a Integer b Integer > Integer
""" 
 Return value type is covariant with argument types.
"""

plus a Numeric b Numeric > Numeric
""" 
 Return value type is covariant with argument types.
"""

minus a Numeric b Numeric > Numeric
""" 
 Return value type is covariant with argument types.
"""

neg a Numeric > Numeric
""" 
 Return value type is covariant with (same as) argument type.
"""

		
// Collection methods		
		
len c Collection > Int
"""
 Returns the number of elements in the collection <span class="future">or map</span>.
"""


// I/O Methods

print ...a Any
"""
 Prints a representation of the argument object/value(s) on the standard output, with a space separating each printed object/value.
"""	


// String methods
	
len s String > Int
"""
 Returns the number of bytes in the String. This is not the number of unicode codepoints, which may be fewer.
"""	

contains s String substr String > Bool 
"""
 Returns whether s contains the substring substr.
"""
	
</pre></code>	
<p>
	Three more built-in methods; <b>dub</b>, <b>summon</b>, and <b>exists</b>, are explained fully in the next section, which explains relish's support for data persistence.
</p>



<a name="DataPersistence"><h3>Data Persistence</h3></a>   
    <code><pre>
car1 = Car  // Construct a Car object and assign it to variable car1
car1.odometerReading = 182430
engine1 = Engine
engine1.horsePower = 120
belt = TimingBelt
car1.engine = engine1 

dub car1 "FEC 092"  // Make the car object persistent in the local database, 
                    // using the license plate# as the official, canonical name
                    // of the persistent object. Directly and indirectly associated 
                    // objects are automatically made persistent too. 

belt.dateOfManufacture = "2012/07/24"  // This TimingBelt is not yet persistent.
engine1.timingBelt = belt  // But now it is!
car1.odometerReading = 194729
    </pre></code><br/>
    <p>
      Now, in a separate run of a relish program that uses the same local database...
    </p>
    <code><pre>
myCar = <span class="future">Car:</span> summon "FEC 092"
print myCar.engine.timingBelt.dateOfManufacture  // prints 2012/07/24
print myCar.engine.horsePower  // prints 120
print myCar.odometerReading  // prints 194729
person = Person
person.firstName = "Eric"
myCar.owner = person
    </pre></code><br/>
    <p>
      Now, in yet another run of a relish program that uses the same local database...
    </p>
<code><pre>
if exists "FEC 092"
   myCar = <span class="future">Car:</span> summon "FEC 092"
else
   myCar = Car
   dub myCar "FEC 092"

myCar.maxSpeed = 130    

joesCar = Car
dub joesCar "552 LVH"
joesCar.odometerReading = 253016
joesCar.maxSpeed = 170   
person = Person
person.firstName = "Joe"
joesCar.owner = person

bobsCar = Car
dub bobsCar "NKL 288"
bobsCar.odometerReading = 78210
bobsCar.maxSpeed = 105   
person = Person
person.firstName = "Bob"
bobsCar.owner = person

alicesCar = Car
dub alicesCar "089 SFR"
alicesCar.odometerReading = 43978
alicesCar.maxSpeed = 140   
person = Person
person.firstName = "Alice"
alicesCar.owner = person
</pre></code>
<p>
  Finally, in yet another run of a relish program using that database, lets
  fetch from the database the fast cars that are not quite yet on their deathbed.</p>
<code><pre>
viableFastCars = []Car "odometerReading < 200000 and maxSpeed > 110 order by maxSpeed desc"
for car in viableFastCars
   print car.owner.firstName

// prints
// Alice
// Eric 

</pre></code>
<h4>Overview of relish's data persistence mechanism</h4>
<p>
  relish's local data persistence mechanism currently uses a sqlite3 database to store data objects.
  Transaction control (deferral of commit) is not yet implemented, but is in the language roadmap.
  relish's local persistence mechanism MAY be extended to work with other rdbms systems, and these
  would most likely be done in the order postgresql, mysql, ...?
</p>
<p>
  relish's persistence mechanism is transparent (also known as orthogonal). This means that once
  you have dubbed a data object with an official (canonical) name, to make it persistent, the object's state
  is automatically saved to the database at that point, and is automatically re-saved whenever its
  state changes. Other objects reachable in the object's attribute or relation network are also
  infected with persistence by their reachability from the newly persistent object, and are similarly
  automatically saved to the database when their state is updated. 
</p>
<p>
There are three ways to retrieve data objects from the database into memory in a new instance
of a relish program. 
<ul>
<li>The first is to summon the object by its official canonical name.</li>
<li> The second is to follow the chain of reference from a retrieved persisted object, to find associated objects. You just use ordinary object attribute accessing notation in the programming language to do this (e.g. car.owner) and the associated object is automatically fetched into memory from the database.</li>
<li>The third retrieval method is to construct a list of the type of object you want e.g. cars = []Car but to include a String argument after the []Car list constructor. The argument String should contain SQL selection criteria (i.e. the tests that occur in a WHERE clause) and can also have a SQL order by clause.
  Currently, the selection criteria expressions are limited to those involving the immediate primitive-valued attributes of the data type whose object instances are to be selected and retrieved into memory. This form of list construction expression will result in a list of those Cars which meet the SQL selection criteria, ordered as per the SQL order by clause.<br/><em>IMPORTANT NOTE: The current implementation of SELECT-style object retrieval is not polymorphic. You must currently construct a list of a most-specific data type which has no subtypes. This restriction should disappear.</em> 
  </li>
</ul>
</p>
<p>
  Currently, only a structured object can be dubbed with an official name to make it persistent.
  However, primitive values and collections which are reachable by reference from that object 
  are also persisted along with it.
</p>
<h4>Data Persistence Implementation Details</h4>
<p>
Under the hood, relish's persistence mechanism stores data objects using multiple-table inheritance-mapping. Each object is represented by a row in the RObject table, and also by a row in perhaps several other tables; Each datatype declared in a relish program has a corresponding database table. An object occurs as a row in each type-table that corresponds to a data type in the object's type lattice.
The object's RObject table row holds the object's full universally unique id, the object's data type, and some status flags. The object's row in each type table holds the the object's id, and the values of whichever primitive-value attributes of the object are defined in that type.
</p>
<p>
  A query to fetch an object's state therefore is a join query on the id of the object, across the RObject table and the type tables applicable to the object.
</p>
<p>
  A data-type attribute which refers to another structured object is represented in the database by an association table (also known as a join table).
  The association table contains rows with the id of the first object and the id of the attribute-value object.
  Association tables are also used to represent multi-valued attributes (collections) and to represent relish's first-class relations between data types.
</p>
<p>
  You can view a relish sqlite3 database using a properly functioning sqlite browser/manager tool, or with the sqlite3 command-line interface.
  Note that the popular free "Sqlite Database Browser" and "Sqliteman" tools are buggy with respect to complex database table names so do not work with relish databases. MesaSqlite for Mac (shareware) works well as does the Firefox Sqlite Browser Plug-in. It is inadvisable to modify a relish sqlite database with a database tool, and completely insane to do so while a relish program is running on it.
</p>






  <a name="DataTypeDeclarations"><h3>Data Type Declarations</h3></a>   


<h4>Declarations of data types that inherit from other Data Types</h4>
<code><pre>

Lollipop &lt;: Candy  
"""
 A lollipop is a subtype of candy which has a stick
 and a ball of coloured sugar.
 The lollipop inherits attributes and relations from its supertype, Candy, 
 such as price and a relationship with a CandyStore.
"""
   stick PaperCylinder

   ball SugaryMass


Polygon &lt;: Shape2D ClosedCurve  // Only if all types are simple single word (non-parameterized)
"""
 A polygon is a closed curve - a sequence of line-segments joined end-to-end to form a ring.
"""
   ...rest of type declaration omitted in example...


Polygon 
&lt;:
   Shape2D
   ClosedCurve
"""
 A polygon is a closed curve - a sequence of line-segments joined end-to-end to form a ring.
"""
   ...rest of type declaration omitted in example...
</pre></code><br/>

<p>
  NOTE: The issue of how to deal with a data type that has multiple supertypes that each define the same attribute has not been dealt with yet in relish. For now, avoid this situation when defining your datatypes or bad things are likely to happen. It is probable that an attribute name-aliasing mechanism such as Eiffel's will be used to resolve this, but that will complicate the persistence-mapping and object-fetch-query code, so it may take a while for the capability to arrive.
</p>





</div>

</body>
</html>