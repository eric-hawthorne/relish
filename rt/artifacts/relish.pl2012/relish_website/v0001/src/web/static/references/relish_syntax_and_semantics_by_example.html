<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>
relish by example - relish programming language
</title>

<meta name="keywords" content="relish programming language web application development framework persistence" />
 <meta name="description" content="Home page for relish(TM), an application programming language which includes a simple full-stack web application framework and transparent persistence. Focus is on simplicity and minimalism via very strict enforcement of conventions. The name comes from the language's inbuilt construct of relations between datatypes. A programmer can express an entity-relation model of the application domain directly in the language then associate instances. Methods are owned by tuples of datatypes, and are dispatched by multi-argument multimethod dispatch.
relish is implemented in Go, and inherits/wraps some Go features like goroutine concurrency and channels, but is almost entirely unlike Go in language constructs and philosophy." />
 

 <link rel="stylesheet" type="text/css" id="stylesheet"
       href="/styles/default.css" />


</head>
<body>
  <div id="header">	
  <table>
	<tr>
	  <td>	
        <img src="/relish_logo4_small.png">
      </td>
	  <td>	
         &nbsp; &nbsp;
      </td>
	  <td>	
        <h1>relish<span class="trademark">&#8482;</span></h1>
      </td>
	  <td style="width: 4em">	
         &nbsp; &nbsp;
      </td>
	  <td>	
        <h2>relish Syntax and Semantics By Example <span class="h2small">- From the Inside Out</span></h2>

      </td>
    </tr>
  </table>
  </div>
  <div id="tutorials_button" class="menubutton">
	Tutorials
  </div>
  <div id="references_button" class="menubutton">
	References
  </div>
  <div id="packages_button" class="menubutton">
	Packages
  </div>
  <div id="download_button" class="menubutton">
	DOWNLOAD
  </div>	
<div id="index">
	<a href="#Introduction">Introduction</a><br/>	
	<a href="#Variables">Variables</a><br/>
	<a href="#ReservedWords">Reserved Words</a><br/>
	<a href="#Constants">Constants</a><br/>	
	<a href="#DataTypes">Data Types</a><br/>	
	<a href="#TypeParameters">Type Parameters</a><br/>	
	<a href="#InbuiltDataTypes">Inbuilt Data Types</a><br/>			
  <a href="#LiteralValues">Literal Values</a><br/>   	
  <a href="#AssignmentStatements">Assignment Statements</a><br/>    
  <a href="#ConstantDeclarations">Constant Declarations</a><br/>   
  <a href="#ControlStatements">Control Statements</a><br/>   
  <a href="#MethodCalls">Method Calls</a><br/>    
</div>  
<div id="content_manual">
	<a name="Introduction"><h3>Introduction</h3></a>

			<p>
			This reference manual shows and explains relish&#8482; programming language constructs, starting from the most basic expressions and statements, and proceeding on to control constructs and beyond. Each construct is shown by one or more examples. Text after or interleaved with the examples explains the syntax rules and the semantics of the construct. <span class="future">language features planned but not yet implemented or enforced by the language compiler-interpreter or runtime environment are shown in text of this colour.</span>
			</p>
			<p>
				relish language constructs have simple syntax rules and minimal use of punctuation and brackets of various kinds. The language also has fewer reserved words than may be typical. However, the language achieves this simplicity and minimalism of expression by means of a trade-off; programmers must adhere to stricter rules than usual as to how and where each language construct is to be written in the program source text.
			</p>
			<p>
				Because of these strict syntax and code layout rules, it is strongly suggested that you begin creating relish programs, when you are first learning the language, by copy-pasting examples of language constructs from tutorials, example programs, code recipes, or from this manual. 
				The examples will be formatted and laid out correctly, and you can modify the code to your needs from that starting point, and learn the conventions as you go.
			</p>

	<a name="Variables"><h3>Variables</h3></a>		
    <code>
    a  b  c  a1  source240v  amount lineWidth  stateOfPlay  line1Length  bitWidth32  
    </code><br/><br/>
    Usage in context:<br/><br/>
    <code>
    a = 2<br/>
    lineWidth = a
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Variable names are camel-case latin-1 alphanumeric beginning with a lower case letter.
Digits count as lower case letters in the camel-case rule, except are not allowed as the first character of the name as
a whole, nor as the first character of any lower case word after an upper case letter. So theWord2 is allowed but theW2 is not.
The name as a whole cannot end with an upper case letter. Multiple upper case letters together are not permitted.
Note that underscores are not permitted (since they are an alternative to camel-case word separation.)    	
    </p>
<p>
Some names of this form may not be used as variable names:
<ul>
<li>the relish language's reserved words are excluded,</li>
<li>the name of any method visible in the scope,</li>

<li> the last name-part of any unaliased imported package,</li> 
<li> the package alias of any aliased imported package,</li> 
<li><span class="future">a name of a parameter of the containing method is already implicitly defined as a strictly typed variable in the method so may not be re-assigned to a value-type incompatible with the parameter's type specification.</span></li>	
</ul>
</p>

        <p>
    	<b>Semantics:</b>
    </p>
    <p>
	A variable is a named and re-assignable store for a value of an expression. The variable can be used as an expression, and yields the value that is stored in it at the time it is used as an expression. All variables are local variables inside a <a href="#Methods">method</a> body. 
	Variables are created by their first use in a method body. If the value assigned to a variable is a structured object or a collection, then the assignment is by reference, not by value-copy. Simple primitive values such as Int, Float are assigned by value.
    </p>
	

	<span class="future">The type of a variable is not stated explicitly when defining the variable. If you assign to a variable in multiple places inside a method body, the known types of the values assigned in the different places must form a type hierarchy. That is, if values of different known types are
	assigned in different assignment-occurrences, then at least one of those known types must be a common supertype of all the others. The type of the variable is then taken to be that common supertype of the known types of values assigned to it in the various assignment occurrences in the method. 
    </span>





	<a name="ReservedWords"><h3>Reserved Words</h3></a>		
    <code>
    if elif else while for in as break continue of go func true false nil
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>    
    <p>
The reserved words may not be used as variable names, method names, or package name parts or aliases. They are reserved for use to define control constructs and literal values in the language.
</p>


	<a name="Constants"><h3>Constants</h3></a>		
    <code>
    PI  E  MAX_WIDTH  LIMIT1  DIM1_SIZE 
    </code><br/><br/>
    Usage in context:<br/><br/>
    <code>
    PI = 3.1415926535<br/>
    DEFAULT_GREETING = "Hello, World!"
    </code><br/>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Constant names are all-capitalized latin-1 alphanumeric, with single-underscore word separators permitted.
They must begin with a latin-1 capital letter.
Note: All single latin-1 capital letters except T denote constants. T,T1,... denote <span class="future">type parameters (See below.)</span> 	
    </p>
    <p>
    Constants must be defined at the top-level scope of a source code file. They cannot be defined within a method body.
    Constants are visible throughout the package in which they are defined. If their name is referred to inside a package that imports
    the constant-defining package, and if the constant name has been package-qualified in that use, the constant is visible
    in the package that imports the constant-defining package. <span class="future">However, if a constant is defined within the __private__ section of a source code file, its name is never visible outside the defining package.</span>
    </p>
        <p>
    	<b>Semantics:</b>
    </p>
    <p>
    	A constant can (and must when introduced) be assigned the value of an expression once, and thenceforth refers to that value.
    	<span class="future">There must be a restriction on the kind of expressions that can be assigned to constants, due to timing of the execution of the constant assignment statements, but what is that restriction?
    		When in the code load and generation and initialization sequence does the constant expression get evaluated??? Does this need to be changed to move the execution until all the methods etc are properly loaded into the runtime?</span>
	</p>



	<a name="DataTypes"><h3>Data Types</h3></a>		
    <code>
    Int32  Float  String  ClosedCurve  BuggyWhipStorageRackClip    	
    </code><br/><br/>
    Usage in context:<br/>
<code><pre>
add a Float b Float &gt; Float
"""
 A method that adds two floating-point numbers together and returns the result.
"""
</pre></code>
    <p>
    	<b>Syntax:</b>
    </p>
    <p>
Type names are camel-case latin-1 alphanumeric beginning with an upper case letter.
All data type names must begin with at least two letters (upper case followed by lowercase.)
Other details of the name syntax are the same as for variables except for the initial upper case letter for type names.
Note that underscores are not permitted (since they are an alternative to camel-case word separation.)	
    </p>
    <p>
    Data types must be defined at the top-level scope of a source code file. They cannot be defined within a method body.
    Type names are visible throughout the package in which they are defined. If their name is referred to inside a package that imports
    the type-defining package, and if the type name has been package-qualified in that use, the type is visible
    in the package that imports the type-defining package. <span class="future">However, if a data type is defined within the __private__ section of a source code file, its name is never visible outside the defining package.</span>
    </p>
        <p>
    	<b>Semantics:</b>
    </p>
    <p>
    	Each data object/value in a relish program has a data type. The data type of an object/value determines which methods can accept the object/value as an argument, and which methods can return the object/value as one of the method's return values.
	</p>
	<p>
		Data types in relish can inherit attributes and method compatibility from other data types. A data type can inherit from more than one direct supertype. That is, relish has multiple inheritance.
	</p>
	<p>
		Data types are of three kinds, primitive value types, structured object types, and collection types.
	</p>
	<p>
		Primitive value types are such types as Int and Bool and <span class="future">Rune (unicode character)</span>.
	</p>
	<p>
        Structured object types are like the familiar "object classes" of other languages.
        A structured object type is defined by specifying a list of attribute specifications to define the attributes of the object.
        See "data type definition" section for details.        

    <p>
        Collection types are types such as List of T, Map of T T1, Set of T and have element accessing and iterating syntax support in the language, as well as compact syntax support for adding and deleting elements, if the collection is mutable. 
		<span class="future">String may be considered an immutable collection type.</span>
	</p>
	<p>
		<span class="future">Generics: - why are generics always "future" :-(  Data type definitions and type specifications may be parameterized; that is, the type may be defined as a wrapper or holder of objects/values of one or more other data types. For example, BinaryTreeNode of T T is a parameterized data type where the type parameter T stands for any other data type. Each parameterized data type definition effectively creates a set of possible data types, and each parameterized data type specification accepts a set of possible datatypes.</span>
	</p>	
	<p>
		In general, in relish, a data type (or class) does not "own" a set of methods.
		It is more accurate to say that an <b>n-tuple</b> (e.g. an ordered-pair, an ordered triple) of data types in relish owns a set of methods; the n-tuple of types conceptually owns those methods whose parameter signature (of all positional-argument input parameters) is that type tuple.</p>
		<p>
		Methods do not have a privileged argument object which is known as the receiver of the method call.
		Rather, all objects that are (required positional) arguments are the receivers of the method call, and relish's dynamic method dispatch will take account of the actual specific data type of each of the positional argument objects supplied to the call, to decide which method has a parameter type-signature that is the most specifically matching the tuple of argument objects.
     		</p>
		<p>A data type (or class) in relish can only be said to own 1) unary methods whose only input parameter is specified to be of that type, <span class="future">and also 2) special attribute-setter methods which set the values of attributes of a structured data object.</span>
	</p>





		<a name="TypeParameters"><h3><span class="future">Type Parameters</span></h3></a>		
	    <code>
	    <span class="future">T  T1  T2  T3  T4  T5  T6  T7  T8  T9</span>
	    </code><br/><br/>
	    <span class="future">Usage in context:<br/></span>
<code><pre>
<span class="future">LinkedList of T</span>	   
</pre></code>
	    <p>
	    	<span class="future"><b>Syntax:</b></span>
	    </p>
	    <p>
<span class="future">Relish supports parameterized data types (generics) and
	only the names above are valid as type parameters in 
	parameterized type declarations.</span> 	
	    </p>
	   


			<a name="InbuiltDataTypes"><h3>Inbuilt Data Types</h3></a>	
			
			<p>In the following, Type1 &lt;: Type2 denotes that Type1 is a subtype that inherits behaviour from and extends the definition of the supertype Type2</p>	
		    <code><pre>
Any                              (implicit) Abstract supertype of all relish datatypes
RelishPrimitive &lt;: Any           Abstract supertype of all inbuilt primitive data types in relish

Numeric &lt;: RelishPrimitive       Abstract supertype of all primitive number types
Integer &lt;: Numeric               Abstract supertype of all integer types
Int &lt;: Integer                   64-bit signed integer
Int32 &lt;: Integer                 32-bit signed integer<span class="future">
Int16 &lt;: Integer                 16-bit signed integer
Int8 &lt;: Integer                  8-bit signed integer</span>
Uint &lt;: Integer                  64-bit unsigned integer
Uint32 &lt;: Integer                32-bit unsigned integer<span class="future">
Uint16 &lt;: Integer                16-bit unsigned integer
Byte &lt;: Integer                  8-bit unsigned integer
Bit &lt;: Integer                   1-bit unsigned integer</span>
Bool &lt;: RelishPrimitive          Boolean logical type (true,false)
Real &lt;: Numeric                  Abstract supertype of all floating-point numeric types
Float &lt;: Real                    64-bit floating-point number<span class="future">
Float32 &lt;: Real                  32-bit floating-point number
ComplexNumber &lt;: Numeric         Abstract supertype of all complex numeric types
Complex &lt;: ComplexNumber         Complex number consisting of two 64-bit Float parts
Complex32 &lt;: ComplexNumber       Complex number consisting of two 32-bit Float32 parts

Text &lt;: RelishPrimitive          Abstract supertype of all text data types
CodePoint &lt;: Text                A 32-bit unsigned integer representing a Unicode codepoint</span>	 
String &lt;: Text                   immutable byte-array representing UTF-8 encoded CodePoints.<span class="future">			
Callable &lt;: RelishPrimitive      Abstract supertype of all function types
MultiMethod &lt;: Callable          A set of methods in a namespace that share the same name
Method &lt;: Callable               An executable function implementation

NonPrimitive &lt;: Any              Abstract supertype of any type which is not a RelishPrimitive             
Struct &lt;: Any                    Abstract supertype of programmer-defined structured object types
Collection of T &lt;: Any           Abstract supertype of collection classes e.g. List Set Map
List of T &lt;: Collection of T     Collection which maintains elements in a sequence
Set of T &lt;: Collection of T      Collection which holds at most one of each value
Map of T1 T2 &lt;: Collection of T1 Map from one data type to another 

InChannel &lt;: Any                 A channel which can be read from
OutChannel &lt;: Any                A channel which can be written to
Channel &lt;: InChannel OutChannel  A channel which can be read from and written to</span>
</pre></code>
<p><span class="future"><em>Some issues here. Should Struct and Collection and Channel be NonPrimitive? </em></span></p>
		   






  <a name="LiteralValues"><h3>Literal Values</h3></a>    

<h4>Integer literals</h4>
    <code>
    42<br/>
0600<br/>
0xBadFace<br/>
170141183460469231731687303715884105727<br/>  
<span class="future">-42<br/>
-0600<br/>
-0xBadFace<br/>
-170141183460469231731687303715884105727<br/></span>
    </code><br/>
    Usage in context:<br/><br/>
    <code>
    a = 42<br/>
    color = 0xFFCADD<br/>
    <span class="future">n = plus -42 260<br/></span>
    </code>
    <p>
An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0 for octal, 0x or 0X for hexadecimal. In hexadecimal literals, letters a-f and A-F represent values 10 through 15. An optional negation prefix - (which if present must come before the non-decimal base prefix) negates the value represented by the sequence of digits. The negation prefix cannot appear in a literal whose value is 0
    </p>


<h4>Floating-point number literals</h4>

<code><pre>
0.
0.0
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
<span class="future">-72.40
-072.40  // == -72.40
-2.71828
-1.e+0
-6.67428e-11
-1E6
-.25
-.12345E+5</span>
</pre></code>
    Usage in context:<br/><br/>
    <code>
    PI = 3.14159265357989<br/>
    r = 6.67428e-2<br/>
    <span class="future">p = -1.7<br/></span>
    </code>
    <p>
A floating-point literal is a decimal representation of a floating-point constant. It has an integer part, a decimal point, a fractional part, and an exponent part. The integer and fractional part comprise decimal digits; the exponent part is an e or E followed by an optionally signed decimal exponent. One of the integer part or the fractional part may be elided; one of the decimal point or the exponent may be elided.  An optional negation prefix - negates the value represented by the sequence of digits. The negation prefix cannot appear in a literal whose value is 0.
</p>

<h4>Boolean literals</h4>

<code><pre>
true  false
</pre></code>
Usage in context:<br/>
<code><pre>
DEBUG = false

while true
   doSomethingForever
</pre></code>
    <p>
Boolean literals represent the boolean logic values true and false, which are the only two values of inbuilt data type Bool. 
false is the zero-value of the Bool type.  
</p>
<p>
NOTE: In relish, the zero-value of any data type is considered false-equivalent in logical tests (as in "<b>if</b>" "<b>while</b>" "<b>for</b>") and is also considered false-equivalent in the Boolean logic operator functions "<b>and</b>" "<b>or</b>" and "<b>not</b>". nil (non-present non-primitive object) is also considered false.
</p>
So values that test false or act as false in boolean operator functions are:
<pre>
0
0.
false
[]   // empty list
{}   // empty set
{=>} // empty map
""   // empty string
nil
</pre>
All other values of any data type test non-false, and act non-false in boolean operator functions.
</p>


<h4>String literals</h4>

<code><pre>
"Hello, world!\n"  
"\n"
""
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"       // illegal: surrogate half
"\U00110000"   // illegal: invalid Unicode code point

These examples all represent the same string:

"日本語"                                 // UTF-8 input text
"\u65e5\u672c\u8a9e"                    // the explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // the explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // the explicit UTF-8 bytes

A multi-line raw string:

      """
"""   
It was a dark and stormy night.
I had a premonition that I should not keep
writing this long, overwrought, badly formatted, 
and turgidly melodramatic story,
but I couldn't help myself. "Damn!", I said to myself,
this is the end.
"""
</pre></code>
    Usage in context:<br/>
<code><pre>
   firstName = "Jeremiah"
   aphorism = """
"""
No matter where you go,
There you are!
And notice that where I am
is starting at the first column
of the source code file.
But then notice that indentation resumes after me, as if I
weren't present in the source file.
"""
   lastName = "Jones"
   truism = """
"""
Stupid is as
stupid does.
"""   
   age = 9

</pre></code>
    <p>
Strings in relish (currently) exhibit and behave much as string values do in Go, because their underlying implementation is a Go string. 
</p>
<p>
A String literal represents a String constant obtained from concatenating a sequence of characters. There are two forms: single-line interpreted String literals and multi-line raw String literals.
</p>
<p>
Interpreted String literals are character sequences between double quotes "". The text between the quotes, which may not contain newlines, forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \' is illegal and \" is legal), with the same restrictions. The three-digit octal (\nnn) and two-digit hexadecimal (\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \377 and \xFF represent a single byte of value 0xFF=255, while ÿ, \u00FF, \U000000FF and \xc3\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.
</p>
<p>
Multi-line raw String literals are character sequences between triple-doublequote delimiters. 
Within the delimiters, any character is legal. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the delimiters; in particular, backslashes have no special meaning and the string may contain newlines. Carriage returns inside raw string literals are discarded from the raw string value.
</p>
<p>
Because of the heavily indentation-dependent nature of relish source code, multi-line raw string literals are first introduced
in their proper indented location, by a single """. On the following line, there must be another """ at the beginning of the line.
The actual raw string value begins on the next line; the one after the second """. 
The raw string continues until the next (third) """, which must again occur at the beginning of a line of the source code file.
So raw strings are always multi-line. Raw string literal values do not include the initial newline character, but do include the last newline character.
The shortest possible multi-line raw string is 
<pre>
   s = """
"""
"""
</pre>
Which is equivalent to the interpreted string literal "\n". 
</p>
</p>
<p>
One peculiarity of Go strings is that their index operator returns a byte at the ith byte position, whereas the string is fundamentally supposed to be a 
sequence of utf-8 encoded unicode codepoints. Each codepoint, utf-8 encoded, can occupy multiple bytes of the string. Also, disturbingly, the len function of a Go string returns the number of bytes, not the number of unicode codepoints in the string. I don't really like these split-personality
grudgingly unicode behaviours of Go strings, but relish Strings are stuck with them for now.
</p>


	<a name="AssignmentStatements"><h3>Assignment Statements</h3></a>		
    <code><pre>
a = 9

bigBigVariableName = 
   "A very very very very very very very very very long value might have to be on the next line, indented."

a b c = d "something" f

a b c = 9432
        "a string"
        d 

a b c =
   d
   143.65
   f    

obj1.obj2.obj3.a = 143.65

myList[3].myMap["Joe Bloggs"].a[i] = "3155 Kent Street"

coord[0].lat = 49.5
    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
An assignment statement consists of one or more assignable left-side-expressions, followed by the assignment operator "=" followed by one or more expressions that (collectively) must produce the <em>same number</em>** of values as the number of assignable left-side expressions. The "=" must be preceded by a single space. If the right-side expressions are on or begin on the same line as the "=", the ""=" must be followed by a single space, which is followed by the beginning of first right-side expression.
</p>
<p>
The left-side expressions must be simple enough to fit on one-line. The second and subsequent left-side expressions, if any, must be separated from their predecessor by a single space. A Left-side expression must be one of:
<ol>
	<li>A local variable or method parameter in a method body.</li>
	<li>An attribute of a structured object.  
	<li>An indexed position in an ordered collection or a map, specified by <expr>[i] or <expr>[key].
	<li>A path of expressions separated by the infix "." operator. The first expression must be a local variable, method parameter, or an indexed position in a collection/map-valued variable or parameter.  Each subsequent expression in the path may be the name of a unary function, an attribute, or an attribute-getter-function, or may be an indexed position in the value returned by one of these. 
</ol>
</p>
<p>
The right-side expressions may appear in several spatial configurations in the source code file.
<ul>
<li>The first configuration is in-line on the same line as the left side and the " = ". In this configuration, if there are multiple expressions, they must be simple so it is not ambiguous where one expression ends and the next begins. Each of the multiple expressions on the line must be one of a) a simple literal, b) a variable name, c) an index expression, dot-notation expression, or combination thereof, or d) a method call enclosed in brackets (foo a "b"), where the method call itself has only simple literals, variable names, index expressions, or dot-notation expressions as arguments. </li>
<li>The second configuration is multiple right side expressions stacked one below the other, starting with the first right-side expression in its normal in-line position one space to the right of the "=" operator. </li>
<li>The third configuration is one or more right-side expressions stacked one below the other, starting on the line following the left-side expressions and " =". In this case, the right-side expressions must all be indented one indent level from the indent position of the beginning of the assignment statement as a whole. </li>
</ul>
</p>
<p>
**There is one exception to the rule that the right-side expressions must produce the same number of values as the number of l-expressions. The right-side may consist of a single expression which evaluates to an ordered collection (e.g. a list or ordered set) containing exactly the same number of elements as the number of l-expressions. 
</p>
</p>
<p>
<b>Semantics:</b>
</p>



<p>
<span class="future">Restrictions apply that limit which assignments are legal, based on type compatibility considerations and on writeability permissions of object attributes and collections. </span>
</p>
<p>
<span class="future"><em>In the following, the term "the statically known type" of an expression refers to the most specific data type that it can be assumed applies to the expression, based on compile-time type information, lexical program structure, and type inference.</em> </span>
</p>
<dl>
<dt>Assigning to a local variable</dt>
<dd><span class="future">Inside a method body, you can assign a value to a variable. The first encountered assignment implicitly creates the variable. There may be multiple lexical occurrences of assignment to the same variable in the method body. The variable is (implicitly) assigned a type constraint; the (most general) statically known type of the values assigned to it among the different lexical assignment occurrences.
<br/>
	There is a type restriction on assignments to the same variable within a method body: There must exist a statically known type among those of the values assigned to the variable which is a supertype of (or the same as) all of the other statically known types of values assigned to the variable in the method body. </span></dd>	
<dt>Assigning to a parameter of a method</dt>
<dd><span class="future">Inside a method body, you can assign a new value to a parameter of the method. Method parameters are declared with a data type specification. The value you assign to the parameter must be compatible with (same as or a subtype of) the type specified for the parameter.</span></dd>

<dt>Assigning to an attribute of a structured object</dt>
<dd><span class="future">You can assign a value to an attribute of an object. Object attributes are declared with a data type specification. The value you assign to the attribute must be compatible with (same as or a subtype of) the type specified for the attribute. 
<br/>
<!-- Some attributes are flagged as not writeable, or not writeable in certain contexts. Blah blah blah. -->
</span></dd>

<dt>Assigning to an indexed position in a collection or map</dt>
<dd><span class="future">You can assign a value to a position in a mutable ordered collection or a mutable map, or to a position in an ordered multi-valued attribute. Collections, maps, and multi-valued attributes are declared with an element data-type specification. The value you assign to the position in the collection/map/multi-valued attribute must be compatible with (same as or a subtype of) the element data-type specification. 
<br/>
<!-- Some collections are immutable. Blah blah blah. -->
</span></dd>
</dl>











	<a name="ConstantDeclarations"><h3>Constant Declarations</h3></a>	
<!-- PI Float32 = 3.14159265357989 -->		
    <code><pre>
PI = 3.14159265357989

E = 2.17  // or roughly anyway

MAX_WIDTH = 1024
    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
A constant declaration consists of a constant name, followed by the assignment operator "=" followed by an expression. The "=" must be preceded by a single space. If the right-side expression is on or begins on the same line as the "=", the ""=" must be followed by a single space, which is followed by the beginning of the right-side expression.
</p>
<p>
The right-side expression may appear in several spatial configurations in the source code file.
<ul>
<li>The first configuration is in-line on the same line as the left side and the " = ".  </li>
<li>The second configuration has the right-side expression starting on the line following the constant name and " =". In this case, the right-side expression must all be indented one indent level from the indent position of the beginning of the constant declaration. </li>
</ul>
</p>
<p>
A constant declaration can only appear at the top-level lexical scope in a source code file. That is, it must begin in the 1st column of the source code file. It may not occur inside a method body or type declaration.
</p>
</p>
<p>
<b>Semantics:</b>
</p>
<p>
A constant can only be assigned a value once, at its declaration. The name then represents that value and can be used as the value in an expression.
Constant names are exported from the package in which they occur <span class="future">unless they are declared within the __private__ section of a source code file, in which case they are only visible within the package.</span>
</p>



	<a name="ControlStatements"><h3>Control Statements</h3></a>	
	
	<h4>"if" conditional</h4>
    <code><pre>
	
if lt x 0
   x = neg x

if lt x 0
   x = 0
else
   x = 1
	
if some
      condition
      expression
   statement
   statement
elif another condition
             expression
   statement
   statement
   statement
elif aThird condition expression
   statement
else
   statement
   statement
    </pre></code>
<p>
<b>Semantics:</b>
</p>
<p>
If the test expression evaluates to any non-false value, the immediately following indented clause (statement sequence) is	executed,
otherwise control passes to the next elif test if present, or to an else clause if only that is present, or to the statement following the "if", if neither another elif or an else are present.
If none of the if or elif tests pass, and an else is present, its indented clause (statement sequence) is executed.
</p>
<p>
"if" is a statement but not an expression. It does not return a value.
</p>

	<h4>"while" loop</h4>
    <code><pre>
while neq (location cows) home
   herd cows	
   sleepRough
   drink COWBOY_COFFEE
	
while some
         condition
         expression
   statement
   if condition
      break
   elif condition2
      continue
   statement
elif another condition
             expression
   statement
   statement
elif aThird condition expression
   statement
else
   statement
   statement
    </pre></code>
<p>
<b>Semantics:</b>
</p>
<p>
While the test expression evaluates to any non-false value, the immediately following indented clause (statement sequence) is executed, then the 
test expression is evaluated again, and so on.
</p>
<p>
"while" is a statement but not an expression. It does not return a value.
</p>
<p>
A while conditional can optionally include alternative clauses (elif,else). The alternative clauses are tested/invoked only if the while condition is false initially (i.e. if the loop is not entered).
</p>

  <h4>"break" statement</h4>
  <p>
    A "break" statement may occur inside the statement sequence body of a "while" loop or "for" loop. If it is executed, the break statement
    causes execution to immediately resume at the first statement after the "while" or "for" loop.
  </p>
  <p>
    The break statement accepts one optional positive integer argument, which is the number of containing loops to break out of.
    If the argument is omitted, it is equivalent to "break 1".
  </p>
  <code><pre>
while true
   while someOtherCondition
      if tired
         break 2
      doMoreWork
   print "Hello"
print "Finally done."

// If the tired condition becomes non-false, execution resumes outside both loops, 
// and "Finally done." is printed without another "Hello"   
  </pre></code>

  <h4>"continue" statement</h4>
  <p>
    A "continue" statement may occur inside the statement sequence body of a "while" loop or "for" loop. If it is executed, the continue statement
    causes execution to skip over the rest of the statements in the statement sequence body of the loop, and return to the top of the loop; that is, the next thing to execute will be the "while"'s test again, or the "for"'s increment statement or increment-then-test.
  </p>
  <p>
    The continue statement accepts one optional positive integer argument, which is the number of containing loops to jump to the top of the next iteration of.
    If the argument is omitted, it is equivalent to "continue 1".
  </p>	
  <code><pre>
while someCondition
   print "Hello"
   while someOtherCondition
      if tired
         continue 2
      doMoreWork
      print "Working on the railroad."
   print "Goodbye"
print "Finally done."

// If the tired condition becomes non-false, execution resumes at the next test of someCondition 
// and if that is non-false, "Hello" is printed before another "Working on the railroad." and before another "Goodbye"  
  </pre></code>  


<h4>"for" loop</h4>
    <code><pre>

// "for" forms that iterate over a collection <span class="future">or map</span>, 
// setting an index<span class="future">/key</span> variable and/or an element value variable 
// to refer successively to each (position and) element in the collection<span class="future">/map</span>.

for i val in someList<span class="future">OrOrderedSet</span>
   statement
   statement

for i val        
   in 
      someList<span class="future">OrOrderedSet</span>
   statement
   statement
<span class="future">
for key val in someMap  
   statement
   statement

for key val        
   in 
      someMap
   statement
   statement   
</span>
for val in someList<span class="future">OrSet</span>
   statement
   statement
<span class="future">
for key in someMap  
   statement
   statement   

for i key val in someOrderedMap  
   statement
   statement

// for an ordered map, the val is the key in this case</span>
for i val1 val2 in someList<span class="future">OrOrderedSetOrOrderedMap</span> someOtherList<span class="future">OrOrderedSetOrOrderedMap</span> 
   statement
   statement

<span class="future">// The val variables are assigned the zero-value of the type 
// when their collection is exhausted before other collection(s).</span>

for i val1 val2 val3                             
   in 
      someList<span class="future">OrOrderedSetOrOrderedMap</span>       
      someOtherList<span class="future">OrOrderedSetOrOrderedMap</span>   
      someThirdList<span class="future">OrOrderedSetOrOrderedMap</span>
   statement
   statement


for val1 val2 in someList<span class="future">OrOrderedSetOrOrderedMap</span> someOtherList<span class="future">OrOrderedSetOrOrderedMap</span>
   statement
   statement      


<span class="future">      
// Traditional C-style "for" loop incrementing and testing index variables

for i = 0 
    less i n
    i += 1
   statement
   statement

for i j =
       min a b
       min c d
    and less i m
        less j n
    i += 1
    j = calcJ i
   statement
   statement

for i = 0   less i n   i += 1  // one-line 3-spaces-separated form allowed if a single index-variable
   statement
   statement</span>
    </pre></code>
<p>
<b>Semantics: "for" iteration over one or more Collections/Maps</b>
</p>
<p>
Iteration proceeds from the lowest-indexed to highest-indexed element of an ordered collection or ordered map. The single-variable form of "for" can iterate over an unordered set (or unordered map), and returns the elements (keys) in unspecified order.
</p>
<p>
IMPORTANT NOTE: "for" iteration is <b>not thread-safe</b>. <span class="future">You need to lock explicitly to ensure exclusive access while iterating, if multiple go-routines may modify the collection/map.</span>  
</p>
<p>
IMPORTANT NOTE: The behaviour of "for" iteration over collections/maps which are being modified (by the same or another go-routine) during the iteration is <b>undefined</b>. That means you should never attempt it. It may or may not cause a panic, but even if it does not, the execution sequence and index and value variable settings are undefined and cannot be relied on.</span>  
</p>
<p>
<b> <span class="future">Semantics: "for" with index incrementing and test expressions</span></b>
</p>
<p>
   <span class="future">TBD</span> 
  </p>


  <a name="MethodCalls"><h3>Method Calls</h3></a>   
    <code><pre>
<span class="subtle">1.</span> foo 19 "fast" body.arm[1].elbow.angle[2]

<span class="subtle">2.</span> foo (bar 253 c d[2] a.b) "fast" (calculateAngle opp adj)

<span class="subtle">3.</span> positionAndStamp envelope 
                    rubberStamp

<span class="subtle">4.</span> positionAndStamp
      envelope
      fetchAppropriateStamp rubberStampBox "PAID"                

<span class="subtle">5.</span> positionAndStamp
      envelope
      fetchAppropriateStamp 
         rubberStampBox 
         "PAID"        

<span class="subtle">6.</span> print times 2 PI

<span class="subtle">7.</span> print times 2 
               PI

<span class="subtle">8.</span> print times
            2
            PI

    </pre></code>
<p>
<b>Syntax:</b>
</p>
<p>
Method names have the same syntax as variable names, method-parameter names, structured-object attribute names<span class="future">, and relation-end names</span>. In relish, you must use contextual information (where they appear in the program, how they are juxtaposed with other program elements, and whether a variable or parameter or attribute <span class="future">or relation-end</span> name has been explicitly defined in the scope) to distinguish the two. <b>Aside on Language philosophy:</b> This conflation of the names of named values (e.g. variables, attributes) and the names of functions, which supply values, is deliberate. It promotes object-oriented data hiding, in that the syntax for getting and setting the values of object attributes is identical to the syntax for calling getter and setter methods. The syntax for calling a unary function of an object is also identical to the syntax for getting the value of an attribute of the object. Therefore, the implementor of the object's data type (class) is free to substitute a computed function for an explicitly stored attribute, or vice versa, without requiring change in code that uses the object.
</p>
<p>
A method call consists of the name of the method followed by zero or more argument expressions. There are three allowed spatial configurations of the arguments in the source code:
<ul>
<li>The first configuration is in-line on the same line as the method name, as shown in examples 1. and 2. above. In this configuration, if there are multiple argument expressions, they must be simple so it is not ambiguous where one expression ends and the next begins. Each of the multiple expressions on the line must be one of a) a simple literal, b) a variable name, c) an index expression, dot-notation expression, or combination thereof, or d) a one-line method call which itself has only simple literals, variable names, index expressions, or dot-notation expressions as arguments. </li>
<li>The second configuration is multiple argument expressions stacked one below the other, starting with the first right-side expression in its normal in-line position one space to the right method name, as shown in example 3. above. </li>
<li>The third configuration is one or more argument expressions stacked one below the other, starting on the line following the method name, as shown in examples 4. and 5. above. In this case, the argument expressions must all be indented one indent level from the indent position of the beginning of the method call as a whole. </li>
</ul>
There is one concession to concise expression of a common case; that where a method's single argument is another method call that consumes all remaining arguments. See examples 6., 7., and 8.
In this case, the argument method call can be expressed without being surrounded by round brackets or indented onto the next line.
This form is not allowed if the top-level method requires another argument beyond the value(s) the argument method call returns. 
</p>


<p>
<b>Semantics:</b>
</p>
<p>
A method call first evaluates all of its argument expressions, in left-to-right order. Multiple methods may share the same method name, so multiple dispatch (multimethod dispatch) is performed to choose which method to execute. Once a method is chosen, the argument values are assigned to the method parameters, and the method body statements are executed in sequence until the end of the statement block is reached or a return statement ( "=>" statement in relish ) is encountered. The number of values specified in the method's declaration are returned to the calling context, which may assign those values in an assignment statement, may use them as arguments to another expression or statement, or may discard them. All methods sharing a name (within a package import hierarchy) must be declared to return the same number of values, which may be from 0 to 9 return values.  
</p>
<p>
    <code><pre>
radius theta = polar x y</pre></code>
The polar method (more precisely the polar multimethod i.e. the set of methods sharing that name) has been declared to return 2 values, which are assigned to the radius and theta variables in the calling context.
</p>   
<p>
    <code><pre>
x1 y1 = cartesian polar x y</pre></code>
The cartesian multimethod has been declared to accept two arguments, which the polar method call supplies.
</p>
<p>
    <code><pre>
<span class="future">radius _ = polar x y</span></pre></code>
<span class="future">The calling context only cares about the radius return value and ignores the angle return value by assigning it to the anonymous dummy variable _ .</span>
</p> 
<p>
    <code><pre>
send "message"</pre></code>
The send multimethod, we will suppose, has been declared to return an error status value, but the programmer of the calling context, unwisely, has chosen to silently ignore it.
</p> 






<h4>Multiple Dispatch</h4>
<blockquote>
Multiple dispatch or multimethods or function overloading is the feature of some object-oriented programming languages in which a function or method can be dynamically dispatched based on the run time (dynamic) type of more than one of its arguments. This is an extension of single dispatch polymorphism where a method call is dynamically dispatched based on the actual derived type of the object on which the method has been called. Multiple dispatch generalizes the dynamic dispatching to work with a combination of two or more objects. -- <em>Wikipedia</em>
</blockquote>

<p>
  In a relish package, a given method name may be the name of multiple methods, which may be defined in the current package, in a package directly imported by the current package, or in a package imported directly or indirectly by a directly imported package. The set of such methods, as seen from within a given package, is called the multimethod (of a given name.)
</p>
<p>
When there is a method call, a single method (of the multimethod) must be chosen by the relish runtime environment as the method that will be applied to the arguments and executed. This choice is made by a process of pattern matching the parameter type signature of each method against the run time (dynamic) type of each required positional argument that has been supplied in the method call. 
</p>
<p>
 The following is a description of the multi-argument dynamic method dispatch process used by relish.
 Bear in mind when informally assessing its performance that the full dispatch process is only executed once per program-run
 for a given type-tuple of arguments applied to a given method. Subsequent calls with the same tuple of types of arguments
 take advantage of a type-signature-match cache which selects the method using a single hashtable lookup. 
</p>
<p>
  The elevator-pitch version of the multiple dispatch process:
  <ul>
   <li>Find methods of the multimethod whose parameter type signature is compatible with (same as or a generalization of) the run time (dynamic) types of the actual arguments in the method call.</li>
   <li>From those, choose the method whose parameter type signature is closest in types to the types of the arguments.</li>
   <li>If there is a tie, assess the type signatures of the candidate methods against each other, to determine which method's type signature is
    more specific in an absolute sense in the type-lattice (the ontology) of data types in the program. Pick that method.</li>
 </ul>
</p>
<p>
  Here is the lengthier, more precise description of the multiple dispatch process:
  <ul>
   <li>Find those method implementations of the multimethod whose parameter-type
   signature is the same as or a generalization of the type-tuple of run time (dynamic) types of the actual argument objects/values.
   </li>
   <li>Select from the type-signature-compatible methods the one whose parameter type signature is the minimal Euclidean distance
   (in multi-dimensional type specialization space) from the type-tuple of the run time (dynamic) types
   of the actual argument objects. That is, select the method having the parameter-type-signature that is compatible with and minimally different in types from the argument run time (dynamic) types. Here the <em>method parameter type signature</em> and the <em>list of run-time (dynamic) types of arguments</em> are considered vectors (of length = the method arity) in multi-dimensional type-specialization space.</li>
  <li>If more than one method is equally close in type signature to the
   argument types (measuring Euclidean distance down the specialization paths),
   then the tie is broken by selecting the method whose signature is most specific
   in types compared to the top types in the ontology of data types in the program.</li>
   <li>If there is still a tie, the method which was encountered first (in the multimethod's
   list of methods of a particular arity) is chosen. This last choice is somewhat arbitrary but should almost never need to be invoked as ties in both the first matching criterion (type-tuple Euclidian distance from argument types) and second criterion (absolute specialization-lattice depth of method signature type-tuples) ought to be exceedingly rare.</li>
 </ul>
</p>




<h4><span class="future">"dot-notation" for calling single-parameter (unary) methods</span></h4>
<p>
<span class="future">Subroutines which accept only a single positional argument can (optionally) be called with "dot-notation" syntax:</span>
</p>
<code><pre>
<span class="future">a.foo</span></pre></code>
<span class="future">is equivalent to</span> 
<code><pre>
<span class="future">foo a</span></pre></code>
<span class="future">That is, call method foo on the argument a</span>
</p>
<p>
<span class="future">The dot-notation version can be used in some contexts where prefix calling is not allowed:
It can increase the depth of subroutine-call nesting allowed in a single-line subroutine call.</span>
<code><pre>
<span class="future">
bar a.b.c.foo "frap" d.e.baz</span></pre></code>
<p>
<span class="future">The dot-notation version of unary-method calling provides syntactic equivalence between object attribute access and getter-function
call and unary function call, allowing for object-oriented data encapsulation (data-hiding) without syntactic baggage.</span>
</p>





</div>

</body>
</html>